<!DOCTYPE html>
<html lang="en">
    
<head>
    <title>Quantized Energy Behavior From Waves</title>
    <meta http-equiv="content-type"
          content="text/html; charset=utf-8">
    
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    
    <meta name="author"
          content="Ronald Adam" >
    <meta name="description"
          content="Simulation of a possible mechanism for quantafied energy from waves.">
    <meta name="keywords"
          content="relativity, quantum, gaussian, simulation, wave, particle, feedback, phase, vortex" >
    <meta name="viewport"
          content="width=device-width, initial-scale=1">

<script>   
/* ---- WEBGL SHADERS ----------------------- */

// Functions to be inserted into shaders.

const gaussian_sample = `
vec4 gaussian_sample(sampler2D sampler, vec2 texCoord, float sigma){
    vec2 texSize = vec2(textureSize(sampler, 0));
    vec2 TC = texCoord;

    // Sample sides of expanding square, stop when values are low.
    // Add center first.
    vec4 G = texture(sampler, TC);    // Center always counted.
    float kweight = 1.0;              // Count of samples.

    float m2ss = -2.0 * sigma * sigma;
    int r = 1;              // Radius of kernel.
    float k = 1.0;          // Kernel value at pixel.
    float dist = 0.0;
    while (true) {
        // Find k for this distance.
        //Stays the same till next loop.
        dist = float(abs(r));
        k = exp(dist * dist / m2ss);  // Gaussian curve
        if (k<0.1) {
            break;
        }
        float rtx = float(r)/texSize.x;
        float rty = float(r)/texSize.y;
        G += texture(sampler, TC + vec2( rtx, 0.0)) * k;
        G += texture(sampler, TC + vec2(-rtx, 0.0)) * k;
        G += texture(sampler, TC + vec2( 0.0,-rty)) * k;
        G += texture(sampler, TC + vec2( 0.0, rty)) * k;
        kweight += k * 4.0;
        // Get off center side values along a side.
        for (int dx=1; dx<r; dx++) {
            dist = length(vec2(dx, r));
            k = exp(dist * dist / m2ss);
            if (k<0.1) break;
            float dxt = float(dx)/texSize.x;
            float dyt = float(dx)/texSize.y;
            vec4 sides = texture(sampler, TC + vec2( dxt, rty));
            sides += texture(sampler, TC + vec2(-dxt, rty));
            sides += texture(sampler, TC + vec2( rtx, dyt));
            sides += texture(sampler, TC + vec2( rtx,-dyt));
            sides += texture(sampler, TC + vec2( dxt,-rty));
            sides += texture(sampler, TC + vec2(-dxt,-rty));
            sides += texture(sampler, TC + vec2(-rtx, dyt));
            sides += texture(sampler, TC + vec2(-rtx,-dyt));
            G += sides * k;
            kweight += k * 8.0;
        }
        // Get corner values.
        dist = length(vec2(r, r));
        k = exp(dist * dist / m2ss);
        if (k>0.1) {
            G += texture(sampler, TC + vec2( rtx,  rty)) * k;
            G += texture(sampler, TC + vec2( rtx, -rty)) * k;
            G += texture(sampler, TC + vec2(-rtx, -rty)) * k;
            G += texture(sampler, TC + vec2(-rtx,  rty)) * k;
            kweight += k * 4.0;
        }
        r += 1;
    }
    G /= kweight;
    return G;
}
`

const gaussian_gradient_sample = `
vec4 gaussian_gradient_sample(sampler2D sampler, vec2 texCoord, float sigma){
    vec2 texSize = vec2(textureSize(sampler, 0));
    vec2 TC = texCoord;

    // Sample sides of expanding square, stop when values are low.
    // Add center first.
    vec4 G = gradient_sample(sampler, TC);    // Center always counted.
    float kweight = 1.0;                      // Count of samples.

    float m2ss = -2.0 * sigma * sigma;
    int r = 1;              // Radius of kernel.
    float k = 1.0;          // Kernel value at pixel.
    float dist = 0.0;
    while (true) {
        // Find k for this distance.
        //Stays the same till next loop.
        dist = float(abs(r));
        k = exp(dist * dist / m2ss);  // Gaussian curve
        if (k<0.1) {
            break;
        }
        float rtx = float(r)/texSize.x;
        float rty = float(r)/texSize.y;
        G += gradient_sample(sampler, TC + vec2( rtx, 0.0)) * k;
        G += gradient_sample(sampler, TC + vec2(-rtx, 0.0)) * k;
        G += gradient_sample(sampler, TC + vec2( 0.0,-rty)) * k;
        G += gradient_sample(sampler, TC + vec2( 0.0, rty)) * k;
        kweight += k * 4.0;
        // Get off center side values along a side.
        for (int dx=1; dx<r; dx++) {
            dist = length(vec2(dx, r));
            k = exp(dist * dist / m2ss);
            if (k<0.1) break;
            float dxt = float(dx)/texSize.x;
            float dyt = float(dx)/texSize.y;
            vec4 sides = gradient_sample(sampler, TC + vec2( dxt, rty));
            sides += gradient_sample(sampler, TC + vec2(-dxt, rty));
            sides += gradient_sample(sampler, TC + vec2( rtx, dyt));
            sides += gradient_sample(sampler, TC + vec2( rtx,-dyt));
            sides += gradient_sample(sampler, TC + vec2( dxt,-rty));
            sides += gradient_sample(sampler, TC + vec2(-dxt,-rty));
            sides += gradient_sample(sampler, TC + vec2(-rtx, dyt));
            sides += gradient_sample(sampler, TC + vec2(-rtx,-dyt));
            G += sides * k;
            kweight += k * 8.0;
        }
        // Get corner values.
        dist = length(vec2(r, r));
        k = exp(dist * dist / m2ss);
        if (k>0.1) {
            G += gradient_sample(sampler, TC + vec2( rtx,  rty)) * k;
            G += gradient_sample(sampler, TC + vec2( rtx, -rty)) * k;
            G += gradient_sample(sampler, TC + vec2(-rtx, -rty)) * k;
            G += gradient_sample(sampler, TC + vec2(-rtx,  rty)) * k;
            kweight += k * 4.0;
        }
        r += 1;
    }
    G /= kweight;
    return G;
}
`

const gradient_sample = `
vec4 gradient_sample(sampler2D sampler, vec2 texCoord) {
    // Gradient Magnatude is returned.
    vec2 texSize = vec2(textureSize(sampler, 0));
    float Dx = 1.0 / texSize.x;
    vec4 vx = (texture(sampler, texCoord + vec2(Dx, 0.0)) - texture(sampler, texCoord - vec2(Dx, 0.0)))/2.0;
    float Dy = 1.0 / texSize.y;
    vec4 vy = (texture(sampler, texCoord + vec2(0.0, Dy)) - texture(sampler, texCoord - vec2(0.0, Dy)))/2.0;
    return vec4(length(vec2(vx.r, vy.r)),
                length(vec2(vx.g, vy.g)),
                length(vec2(vx.b, vy.b)),
                length(vec2(vx.a, vy.a)));
}
`


const mpolate = `
float mpolate(float A, float B, float C, float t) {
    //
    //  Smoothly interpolate over time from the midpont
    //  between AB to the midpoint BC.
    //  Value t is position between 0 and 1.
    //
    float t1 = (1.0 - t) * (1.0 - t);
    float L1 = (B - A) * t1;
    float t2 = t * t;
    float L2 = (B - C) * t2;
    return B - (L1 + L2) / 2.0;
}
`
    
// VERTEX SHADERS
const VS_points = `#version 300 es
layout(location = 0) in vec2 aPos;
layout(location = 1) in vec2 aTexCoord;
out vec2 vTexCoord;
void main(void) {
   vTexCoord = aTexCoord;
   gl_Position = vec4(aPos, 0.0, 1.0);
}
`;


// CALCULATION SHADER
const FS_calc = `#version 300 es
precision highp float;
uniform highp sampler2D uSampler;
uniform int   uEdge;
uniform float uSigma;
uniform float uC1;
uniform float uE1;
uniform float uC2;
uniform float uE2;

in vec2 vTexCoord;
out vec4 fragColor4;

${gaussian_sample}

void main(void) {
    vec2 TC = vTexCoord;
    if ((uEdge == 2) && (length(TC - 0.5) > 0.48)) {
       // If edge mode is circular and point outside a circle, skip it.
       discard;
    }
    vec4 y = texture(uSampler, TC);
    float U = y.a;
    float V = y.b;
    float m = U - V;    
    float G = gaussian_sample(uSampler, TC, uSigma).a;
    float a = G - U;
    float w = U + a + m;
    float v = uC1 + pow(abs(m + a), uE1);
    float fb = (v + uC2) / (v + pow(abs(U + a - m/v), uE2));
    fragColor4 = vec4(y.g, y.b, y.a, w * fb);
}
`;


// DISPLAY SHADER
const FS_draw = `#version 300 es
precision highp float;
uniform highp sampler2D uSampler;
uniform sampler2D uColor;
    
uniform float uFrameTime;
uniform float uScale;
uniform int uMode;
uniform int uEdge;
uniform float uSigma;
    
in vec2 vTexCoord;
out vec4 fragColor4;

${gaussian_sample}
${gradient_sample}
${gaussian_gradient_sample}
${mpolate}

void main(void) {
    vec2 texSize = vec2(textureSize(uSampler, 0));
    vec2 TC = vTexCoord;

    if (uEdge == 2 && (length(TC - 0.5) > .49)) {
       discard;
    }

    if (uMode == 0) {
        // Gradient of amplitude.   
        vec4 y = gaussian_gradient_sample(uSampler, TC, .5);
        float v = mpolate(y.a, y.b, y.g, 1.0 - uFrameTime);
        v = clamp(v/uScale, 0.0, 1.0);
        fragColor4 = vec4(pow(v, 4.0), pow(v, 1.5), pow(v, 0.7), 1.0);
    }
    else if (uMode == 1) {    
        // Amplitude.
        vec4 y = texture(uSampler, TC);    
        float v = mpolate(y.a, y.b, y.g, 1.0 - uFrameTime);
        v = clamp((v/uScale + 1.0) * 0.5, 0.0, 1.0);
        fragColor4 = texture(uColor, vec2(v, 0.0));
    }
    else if (uMode == 2) {
        // Momentum of amplitude.
        vec4 y = texture(uSampler, TC);
        float a1 = mpolate(y.b, y.g, y.r, 1.0 - uFrameTime);   
        float a2 = mpolate(y.a, y.b, y.g, 1.0 - uFrameTime);
        float v = (a1 - a2);
        v = clamp(0.5 + v/uScale * 0.5, 0.0, 1.0);
        fragColor4 = texture(uColor, vec2(v, 0.0));   
    }
    else if (uMode == 3) {
        // Acceleration of amplitude.
        vec4 gy = gaussian_sample(uSampler, TC, uSigma);
        vec4 ty = texture(uSampler, TC);
        vec4 dy = gy - ty;   // Acceleration force.
        float v = mpolate(dy.b, dy.g, dy.r, 1.0 - uFrameTime);
        v = clamp(0.5 + v/uScale * 0.5, 0.0, 1.0);
        v = (v < 0.5) ? pow(v * 2.0, 0.5)/2.0 : pow((v - 0.5) * 2.0, 2.0)/2.0 + 0.5;
        fragColor4 = texture(uColor, vec2(v, 0.0));
    }
}`;


// Used to copy render buffer back to calc buffer,
// and to render to an Javascript array.
const FS_copy = `#version 300 es
precision highp float;
uniform highp sampler2D uSampler;
in vec2 vTexCoord;
out vec4 fragColor4;
void main(void) {
    precision highp float;
    fragColor4 = texture(uSampler, vTexCoord);
}`;


// Reverse colors values to swap directioin. (rgba --> abgr>
const FS_swap = `#version 300 es
precision highp float;
uniform highp sampler2D uSampler;
in vec2 vTexCoord;
out vec4 fragColor4;
void main(void) {
    precision highp float;
    vec4 c = texture(uSampler, vTexCoord);
    fragColor4 = vec4(c.a, c.b, c.g, c.r);
}`;
    

/* ---- JAVASCRIPT PROGRAM ------- */

// Values that can be changed though both
// the URL and page interactions.
const VALUES = {"Sigma":2,
                "C1":2,
                "E1":2,
                "C2":0.5,
                "E2":2,
                "Width":256,
                "Height":256,
                "Edge":0,       // 0:Reflect
                "Mode":0,       // 0:Gradient
                "Scale":4,
                "Speed":4,
                "Direction":1,  // -1:reverse 1:forward
                "Animating":0,  // 0:false, 1:true
                "FrameCount":0,
                "FrameTime":0,
                "Seed":0,
               }
               
const IVALUES = {...VALUES}

// Catagories for response.
const MODE = ["Gradient", "Amplitude", "Momentum", "Acceleration"]
const EDGE = ["Reflect", "Wrap", "Rounded"]
const UNIFORMS = new Set(["Sigma", "C1", "E1", "C2", "E2", "uE2"])


const ColorLUT = new Uint8Array([            
    200, 100, 100, 128,
    200, 0,   0,   255, 
    0,   0,   0,   255,
    50,   50,   255, 255,
    100, 100, 255, 128,
]);
    


var canvas, gl, prog_draw, prog_calc, prog_swap, prog_render,
    texture0, texture1, colorlut;

// Enables reapeatable starting conditions.
Math.seed = 0
Math.seededRandom = function(max, min){
    max = max || 1;
    min = min || 0; 
    Math.seed = (Math.seed * 9301 + 49297) % 233280;
    var rnd = Math.seed / 233280;
    return (min + rnd * (max - min));
}


// Used frequently.  
function set_uniform_1i(program, name, value){
    gl.useProgram(program)
    Loc = gl.getUniformLocation(program, name)
    gl.uniform1i(Loc, value)
}

function set_uniform_1f(program, name, value){
    gl.useProgram(program)
    Loc = gl.getUniformLocation(program, name)
    gl.uniform1f(Loc, value)
}


function main() {
    canvas = document.getElementById("canvas")
    
    set_values_from_url()  // If any.
    //IVALUES = {...VALUES}
    Object.assign(IVALUES, VALUES);
    
        // Size is be reset later.
    canvas.width = VALUES["Width"]
    canvas.height = VALUES["Height"]

    var err = "Your browser does not support "
    if (!window.WebGLRenderingContext) {
        alert(err + "WebGL. See http://get.webgl.org")
        return none
    }
    try {
        gl = canvas.getContext("webgl2")
    } catch (e) {}
    if (!gl) {
        alert("Can't get WebGL 2");
        return none
    }

    var ext
    try {
        ext = gl.getExtension("EXT_color_buffer_float");
    } catch (e) {}
    if (!ext) {
        alert(err + "EXT_color_buffer_float");
        return;
    }

    var aPosLoc = 0
    var aTexLoc = 1

    var VS = createShader(gl, gl.VERTEX_SHADER, VS_points)
    gl.enableVertexAttribArray(aPosLoc)
    gl.enableVertexAttribArray(aTexLoc)
    var data = new Float32Array(
        [-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1])
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())    
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)
    gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, gl.FALSE, 16, 0)
    gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, gl.FALSE, 16, 8)

    prog_draw = gl.createProgram()
    gl.attachShader(prog_draw, VS)
    gl.attachShader(prog_draw, createShader(gl, gl.FRAGMENT_SHADER, FS_draw))
    gl.bindAttribLocation(prog_draw, aPosLoc, "aPos")
    gl.bindAttribLocation(prog_draw, aTexLoc, "aTexCoord")
    gl.linkProgram(prog_draw)

    prog_calc = gl.createProgram()
    gl.attachShader(prog_calc, VS)
    gl.attachShader(prog_calc, createShader(gl, gl.FRAGMENT_SHADER, FS_calc))
    gl.bindAttribLocation(prog_calc, aPosLoc, "aPos")
    gl.bindAttribLocation(prog_calc, aTexLoc, "aTexCoord")
    gl.linkProgram(prog_calc)

    prog_swap = gl.createProgram()
    gl.attachShader(prog_swap, VS)
    gl.attachShader(prog_swap, createShader(gl, gl.FRAGMENT_SHADER, FS_swap))
    gl.bindAttribLocation(prog_swap, aPosLoc, "aPos")
    gl.bindAttribLocation(prog_swap, aTexLoc, "aTexCoord")
    gl.linkProgram(prog_swap)

    prog_render = gl.createProgram()
    gl.attachShader(prog_render, VS)
    gl.attachShader(prog_render, createShader(gl, gl.FRAGMENT_SHADER, FS_copy))
    gl.bindAttribLocation(prog_render, aPosLoc, "aPos")
    gl.bindAttribLocation(prog_render, aTexLoc, "aTexCoord")
    gl.linkProgram(prog_render)

    set_grid_size(`${VALUES["Width"]}, ${VALUES["Height"]}`)  
    
    
    
    // Define color table.
    var width = 5;
    var height = 1;
    var texture = gl.createTexture()
    gl.activeTexture(gl.TEXTURE0 + 3)
    gl.bindTexture(gl.TEXTURE_2D, texture)
    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, width, height)
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, ColorLUT)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)    
    set_uniform_1i(prog_draw, "uColor", 3)
    
    
    set_uniform_1i(prog_draw, "uSampler", 0)
    set_uniform_1i(prog_calc, "uSampler", 0)
    set_uniform_1i(prog_swap, "uSampler", 0)
    set_uniform_1i(prog_render, "uSampler", 0)

    // Update info panel every half second.
    timer = setInterval(update_info, 500)

    // Key listener for display control.
    const box = document.querySelector(".canvas")    
    
    document.addEventListener("keydown", e => {
        var key = e.key
        if (e.target.id==''){        
            if (key==" "){
                if (VALUES["Animating"]){
                    pause()
                }else if (VALUES['Direction']>0){
                    forward()
                }else{
                    reverse()
                }
            }else if (["q", "Q"].includes(key)) {
                /* Random values */
                random_values()
            }else if (['r', 'R'].includes(key)) {
                /* Reset */
                reset_values()
            }else if (key=='ArrowUp') {
                set_speed(VALUES['Speed'] * 1.1)
            }else if (key=='ArrowDown') {
                set_speed(VALUES['Speed'] * .9)
            }else if (key=='ArrowLeft') {
                set_scale(VALUES['Scale'] * .9)
            }else if (key=='ArrowRight') {
                set_scale(VALUES['Scale'] * 1.1)
            }else if (key=='1') {
                set_display_mode(0)
            }else if (key=='2') {
                set_display_mode(1)
            }else if (key=='3') {
                set_display_mode(2)
            }else if (key=='4') {
                set_display_mode(3)
            }
        }else{
            console.log(key)
        }
    })
    
    reset_values()
    pause()
    resize_area()
    animate()
}

function createShader(gl, type, source){
    var shader = gl.createShader(type)
    gl.shaderSource(shader, source)
    gl.compileShader(shader)
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        return shader
    console.log(gl.getShaderInfoLog(shader))
    gl.deleteShader(shader)
}
    
function resize_area() {
        var header = document.getElementById('header').getBoundingClientRect()
        var footer = document.getElementById('footer').getBoundingClientRect()
        var column1 = document.getElementById('column1').getBoundingClientRect()
        var canvas_area = document.getElementById('canvas-area')
        var VH = document.documentElement.clientHeight
        canvas_area.style.height = Math.max(VH - footer.height - header.height - 32,
                                            column1.height - 32) + 'px'
}

function set_grid_size(size){
    // A string is needed for 'size'.  "width, hieght".
    var xysize = []
    var W, H
    try {
        xysize = size.replace('?:[^0-9]', ' ').split(' ')
        W = parseInt(xysize[0])
        H = parseInt(xysize[1])
    } catch (e) {}
    if (!W || !H) {
        alert("invlid width and height values")
        return none
    }

    VALUES["Width"] = W
    VALUES["Height"] = H
    canvas.width = W
    canvas.height = H
    
    document.getElementById("grid-size").value = `${W}, ${H}`

    texture0 = gl.createTexture()
    set_texture(texture0, 0, [])
    
    FBO = gl.createFramebuffer()
    gl.bindFramebuffer(gl.FRAMEBUFFER, FBO)
    gl.viewport(0, 0, W, H);
    gl.framebufferTexture2D(gl.FRAMEBUFFER,
                            gl.COLOR_ATTACHMENT0,
                            gl.TEXTURE_2D,
                            texture0,
                            0)
                           
    texture1 = gl.createTexture()
    set_texture(texture1, 0, [])
    
    FBO1 = gl.createFramebuffer()
    gl.bindFramebuffer(gl.FRAMEBUFFER, FBO1)
    gl.viewport(0, 0, W, H);
    gl.framebufferTexture2D(gl.FRAMEBUFFER,
                            gl.COLOR_ATTACHMENT0,
                            gl.TEXTURE_2D,
                            texture1,
                            0)
                            
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE)
        alert("FBOs are not complete")
        
    set_image()
}

function set_texture(texture, index, image) {
    var W = VALUES["Width"]
    var H = VALUES["Height"]
    gl.activeTexture(gl.TEXTURE0 + index)
    gl.bindTexture(gl.TEXTURE_2D, texture)
    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA32F, W, H)
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, W, H, gl.RGBA, gl.FLOAT, image)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
    set_edge_mode(VALUES["Edge"])
}

// FUNCTIONS USED IN ANIMATIOIN LOOP.
function copy_buffer() {
    // Copy FBO1 back to FBO.
    var W = VALUES["Width"]
    var H = VALUES["Height"]    
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, FBO1)   // Source.
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, FBO)    // Target.
    gl.blitFramebuffer(0, 0, W, H, 0, 0, W, H,
                       gl.COLOR_BUFFER_BIT, gl.NEAREST)
}

function step(){
    // Calculate from FBO to FBO1.
    gl.useProgram(prog_calc)
    gl.bindFramebuffer(gl.FRAMEBUFFER, FBO1)  // Target buffer
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    copy_buffer()
}

function swap_frames(){
    // Swap order of frames.  rgba --> abgr
    gl.useProgram(prog_swap)
    gl.bindFramebuffer(gl.FRAMEBUFFER, FBO1)  // Target buffer
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    copy_buffer()
}

function render() {
    // Used to copy the canvas to an array.
    gl.useProgram(prog_render)
    gl.bindFramebuffer(gl.FRAMEBUFFER, null)  // To screen.
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
}

function draw() {
    // Just Draw it.
    set_uniform_1f(prog_draw, "uFrameTime", VALUES["FrameTime"])
    gl.bindFramebuffer(gl.FRAMEBUFFER, null)
    //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4) 
}


// THE MAIN ANIMATION LOOP.
function animate(time_stamp) {
    if (VALUES["Animating"]) {
        FrameTime = VALUES["FrameTime"] + VALUES["Speed"]
        FrameCount = VALUES["FrameCount"]
        while (FrameTime >= 1.0) {
            step()
            FrameTime -= 1.0
            FrameCount += VALUES['Direction']
            if (FrameCount == 0) {
                pause()
                FrameTime = 0.0;
                break;
            }
        }
        VALUES["FrameTime"] = FrameTime
        VALUES["FrameCount"] = FrameCount
    }
    draw()
    video_frames ++
    requestAnimationFrame(animate)
}


// Set and read values.
function set_display_mode(mode) {
    VALUES["Mode"] = mode
    var label = document.getElementById("Mode")
    label.innerHTML = MODE[mode]
    set_uniform_1i(prog_draw, "uMode", mode)
}

function set_edge_mode(mode) {
    VALUES["Edge"] = mode
    var edge_mode = EDGE[mode]
    var label = document.getElementById("Edge")
    label.innerHTML = edge_mode
    set_uniform_1i(prog_calc, "uEdge", mode)
    set_uniform_1i(prog_draw, "uEdge", mode)
    gl.activeTexture(gl.TEXTURE0 + 0)
    if (["Reflect", "Rounded"].includes(edge_mode)){
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT, gl.CLAMP_TO_EDGE)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT, gl.CLAMP_TO_EDGE)
    }else if (edge_mode=="Wrap"){
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT, gl.CLAMP_TO_EDGE)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT, gl.CLAMP_TO_EDGE)
    }
}

function random_values(){
    Math.seed = Date.now()
    set_value("Sigma", Math.seededRandom(1.0, 4.0).toPrecision(3))
    set_value("C1", Math.seededRandom(1.0, 10.0).toPrecision(3))
    set_value("C2", Math.seededRandom(0.1, 2.0).toPrecision(3))
    set_value("E1", Math.seededRandom(1.0, 3.0).toPrecision(3))
    set_value("E2", Math.seededRandom(1.0, 3.0).toPrecision(3))
    //set_image()
}

function set_image(){
    Math.seed = VALUES["Seed"]   
    var image = make_image()
    set_texture(texture0, 0, image)
    set_texture(texture1, 1, image)
    VALUES["FrameCount"] = 0
}

function random_image(){
    set_seed(Math.seed)
}

function set_seed(val){
    VALUES["Seed"] = val
    document.getElementById('Seed').value = val
    set_image()
}

function set_direction(d){
    if (VALUES["Direction"] != d){
        swap_frames()
        VALUES["Direction"] = d
    }
}

function forward(){
    document.getElementById("Forward").style.color = "red"
    document.getElementById("Pause").style.color = "black"
    document.getElementById("Reverse").style.color = "black"
    set_direction(1)
    VALUES["Animating"] = 1    
}

function reverse(){
    document.getElementById("Forward").style.color = "black"
    document.getElementById("Pause").style.color = "black"
    document.getElementById("Reverse").style.color = "red"
    set_direction(-1)
    VALUES["Animating"] = 1      
}

function pause(){
    document.getElementById("Forward").style.color = "black"
    document.getElementById("Pause").style.color = "red"
    document.getElementById("Reverse").style.color = "black"
    VALUES["Animating"] = 0
}

function set_speed_from_slider(value) {
    // Set speed from slider.
    var speed = Math.pow(value/10000, 2) * 100
    document.getElementById('Speed').value = speed.toFixed(3)
    document.getElementById('speed_slider').value = value
    VALUES["Speed"] = speed
}

function set_speed(s) {
    // Set speed from value.
    document.getElementById('Speed').value = parseFloat(s).toFixed(3)
    document.getElementById("speed_slider").value =  Math.sqrt(s/100) * 10000
    VALUES["Speed"] = s   
}

function set_scale_from_slider(value) {
    // Set scale from slider.
    var scale = Math.pow(value/1000, 2) * 50
    set_uniform_1f(prog_draw, "uScale", scale)
    document.getElementById('Scale').value = parseFloat(scale).toFixed(3)
    document.getElementById('scale_slider').value = value
    VALUES["Scale"] = scale.toFixed(3)
}

function set_scale(scale) {
    // Set scale from value.
    //scale = parseFloat(scale).toFixed(3) 
    set_uniform_1f(prog_draw, "uScale", scale)
    document.getElementById('Scale').value = parseFloat(scale).toFixed(3)
    document.getElementById('scale_slider').value = Math.sqrt(scale/50) * 1000
    VALUES["Scale"] = scale
}

// STATUS UPDATE FUNCTION.
var fps_timer = 0
var sim_frames = 0
var video_frames = 0

function update_info() {
    now = Date.now()
    count = VALUES["FrameCount"]
    var elapsed_time = now - fps_timer;
    var fps = Math.round(1000 * (count - sim_frames) / elapsed_time)
    document.getElementById("sim_frame_rate").innerHTML = fps
    fps = Math.round(1000 * video_frames / elapsed_time)
    document.getElementById("video_frame_rate").innerHTML = fps
    document.getElementById("FrameCount").innerHTML = count
    sim_frames = count   
    video_frames = 0    
    fps_timer = now
}

/*
//TODO: Work on this if it's needed. Just leaving this here for now.
    
function read_buffer(){
    var image = new Float32Array(4 * X * Y)
    var pixels = new Uint8Array(4 * X * Y);
    render()
    gl.readPixels(0, 0, X, Y, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    var x = 0
    while (x<pixels.length) {
        r = pixels[x]
        g = pixels[x+1]
        b = pixels[x+2]
        a = pixels[x+3]
        image[x]   = (r/256.0 - .5) * 8
        image[x+1] = (g/256.0 - .5) * 8
        image[x+2] = (b/256.0 - .5) * 8
        image[x+3] = (a/256.0 - .5) * 8
        x += 4
    }
    return image
}
*/

function make_image(){
    // Insert some pulses for the starting condition.
    var W = VALUES["Width"]
    var H = VALUES["Height"]
    var image = new Float32Array(4 * W * H)
    var n = Math.round(Math.seededRandom(1, 6))  // More doesn't help.
    for (var p=0; p<n; p++){
        // Insert a random pair.
        var h = Math.seededRandom(W/100, W/20)
        var psign = 1
        for (var k=0; k<2; k++){
            var t = 0
            var xpos = Math.seededRandom(W * 0.2, W * 0.8)
            var ypos = Math.seededRandom(W * 0.2, H * 0.8)
            for (var i=0; i<H; i++){
                for (var j=0; j<W; j++){
                    var x = (j - xpos)
                    var y = (i - ypos)
                    var d = Math.sqrt(x*x + y*y)
                    var w = gaussian(d, 1.0, 0.0, h) * psign
                    // Each color is a frame in time. r,g,b,a = t, t-1, t-2, t-3
                    image[t++] += w * 0.9
                    image[t++] += w
                    image[t++] += w
                    image[t++] += w * 0.9
                }
            }
            psign *= -1
        }
    }
    return image
}

function gaussian(x, a, b, sigma){
    // Find height y of x on gaussian curve,
    // scaled to amplitude a, with center of curve at b.
    var dist = x - b
    var y = a * Math.exp(-((dist * dist) / (2.0 * sigma * sigma)))
    return y
}

function read_values(){
    vals = ""
    for (var key in VALUES){
        vals += `${key}:${VALUES[key]} `
    }
    return vals
}

function copy_values() {
    var vals = read_values()
    navigator.clipboard.writeText(vals)
}

function copy_url(){
    var base_url = window.location.href.split('?')[0]
    var vals = "?"
    for (var key in VALUES) {
        vals += `${key}=${VALUES[key]}&`
    }
    navigator.clipboard.writeText(base_url + vals.slice(0, -1))
}
 
function open_url() {
    var url = window.location.href
    window.open(url);
}

function get_url_values() {
    var vals = {}
    var parts = window.location.href.split('?')
    if (parts.length<2) {
        return vals
    }
    var pairs = parts[1].split('&')
    for (const kvPair of pairs) {
        var pair = kvPair.split('=')
        vals[pair[0]] = pair[1]
    }
    return vals
}

function set_values_from_url() {
    // Call reset_values after this.
    // And after setting the texture size.
    var vals = get_url_values()
    for (id in VALUES) {
        if (id in vals){ 
            VALUES[id] = parseFloat(vals[id])
        }
    }
}

function reset_values() {
    set_grid_size(`${IVALUES["Width"]}, ${IVALUES["Height"]}`)
    for (id in VALUES) {
        set_value(id, IVALUES[id]);
    }
}

function set_value(id, val){
    if (id in VALUES){
        if (UNIFORMS.has(id)){
            document.getElementById(id).value = val            
            val = parseFloat(val)
            set_uniform_1f(prog_calc, 'u'+id, val)
            if (id == "Sigma"){
                set_uniform_1f(prog_draw, 'u'+id, val)  //Used in both.              
            }
            VALUES[id] = val
        }else if (id == 'Edge'){
            set_edge_mode(val)
        }else if (id == 'Mode'){
            set_display_mode(val)
        }else if (id=="Scale"){
            set_scale(val)
        }else if (id=="Speed"){
            set_speed(val)
        }else if (id=="Forward"){
            forward()
        }else if (id=="Reverse"){
            reverse()
        }else if (id=="Puase"){
            pause()
        }else if (id=="Seed"){
            set_seed(val)
        }else{
            VALUES[id] = val
        }
    }else{
        console.log('unknown key:', id, val)
    }
}
</script>


<style>

/* Standard tags */
body {
    background-color: #d8d8dd;
    height: 100%;
    max-width: 95vw;
    padding: 0;
    margin: auto;
    
    /* lets curser be changed */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    /* user-select: none; */
}

.page {
    width: 100%;
    padding: .5em;
    margin: 0;
    margin-right: 1em;  
}

h1 {
    margin: 0;
    padding: 0;
}
h2 {
    margin: 0;
    padding: .5em;
    font-size: 1.5em;    
}
h3 {
    font-size: 1.25em;
    color: mediumblue;
}
h4 {
    display: inline-block;
    font-size: 1em;
    color: darkcyan;
    padding: 0 1em 0 0;
    margin: 0;
}
button {
    display: inline-block;
    height: -moz-fit-content;
    height: fit-content;
    margin: .125em;
    padding: 0.125em .5em 0.125em .5em;
}
input {
    display: inline-block;
    color: #008;
    background-color: white;
    height: 1.5em;
    padding: 0 .25em 0 .25em;
    margin: .1em;
    border-style: solid;
    border-width: 1px;
    border-radius: 3px;
    border-color: grey;
}

/* Colors */
.grad-blue {
    background-image: linear-gradient(to bottom right, #ffffff, #ddddff, #f0f0f8);
    color: #066;
}
.grad-gold {
    color: #006;
    background-image: linear-gradient(to bottom right, #ffffff, #eeeedd, #dddddd);
}
.grad-grey {
    color: #006;
    background-image: linear-gradient(to bottom right, #ffffff, #eeeeee, #dddddd);
}
.green {
    color: green;
}
.teal {
    color: teal;
}

.outline {
    border-style: solid;
    border-width: 1px;
    border-radius: 3px;
    border-color: grey;
}

/* Fonts */
.small {
    font-size: small;
}
.medium {
    font-size: medium;
}

/* Content holders */
.header {
    padding: .5em 1em .5em 1em;
    margin: .5em;
}

.content {
    padding: .5em 1em .5em 1em;
    margin: .5em;
}

#footer {
    padding: .5em 1em .5em 1em;
    margin: .5em;
}


.card-square {
    padding: 0;
    margin: 0;
    border-style: solid;
    border-width: 1px;
    border-color: #888;
    box-shadow: 3px 6px 5px rgba(0, 0, 0, 0.3);
}

.card-rounded {
    padding: .5em 1em .5em 1em;
    margin: .25em;
    border-style: solid;
    border-width: 1px;
    border-radius: 7px;
    border-color: #aaaaaa;
    box-shadow: 5px 5px 7px rgba(0, 0, 0, 0.2);
}


/* Used for about information window. */
.modal {
    /* The Modal (background) */
    display: none;
    position: fixed;
    z-index: 2;
    left: calc(100% - 45em);
    width: 40em;
    top: .5em;
    height: calc(100vh - 3.5em);
    padding: .5em 1em .5em 1em;    
    background-color: grey;
}
.modal-header {
    display: block;
    height: 4em;
    width: 38em;
    color: teal;
}
.modal-scroll {
    display: block;
    position: fixed;
    background-color: #f8f8f8;
    width: 38em;
    top: 5em;
    height: calc(100vh - 9.5em);
    overflow-y: scroll;
    text-align: left;
    padding: 1em;
    border-style: solid;
    border-width: 1px;
    border-radius: 3px;
    border-color: #888888;
}


.fit-width {
    /* fits width of conetent */
    display: grid;
    width: max-content;
}
.fit-rest {
    /* fits remaining width */
    display: table-cell;
    width: 100%;
}


.space-between {
    display: flex;
    justify-content:space-between;
}
.space-left {
    display: flex;
    width: 100%;
    justify-content: flex-end;
}
.space-right {
    display: flex;
    width: 100%;
    justify-content: flex-start;
}

.center {
    width: 100%;
    display: flex;
    justify-content:center;
}
.middle {
    display: flex;
    align-items: center;
}

.indent2 {
    padding-left: 2ch;
    display: inline-block;
}

/* These define the width of a div or span.  */
.tab6 {
    width: 6ch;
    display: inline-block;
}
.tab8 {
    width: 8ch;
    display: inline-block;
}
.tab10 {
    width: 10ch;
    display: inline-block;
}
.tab14 {
    width: 14ch;
    display: inline-block;
}
.tab16 {
    width: 16ch;
    display: inline-block;
}
.tab24 {
    width: 24ch;
    display: inline-block;
}

/* Dropdown menu and items. */
.dropdown {
    display: inline-block;   
    position: relative;
    padding: 0 2em 0 2em;
    width: 8ch;
    margin: .2em;    
    color: #00a;
    background-color: #eef;
}
.dropdown-content {
    display: none;
    position: absolute;
    min-width: 10em;
    z-index: 1;
}
.dropdown:hover .dropdown-content {
    display: block;
}
.dropdown-item {
    display: block;
    padding: 0 1ch 0 1ch;
    color: #00a;
    background-color: #dde;
}
.dropdown-item:hover {
    background-color: lightgreen;
}


.coords {
    display: none;
    color: green;
    position:absolute;
    z-index:2;
    text-shadow: 1px 1px #000000;
}

.canvas-container{
    display: inline-block;
    width: 100%;  
    height: 100%;
}

.canvas-area {
    display: block;
    width: 100%;
    /* height: 35em; */
    height: 10em;
}
.canvas {
    width: 100%;
    height: 100%;   
    object-fit: contain;
}


.speed_slider {
    width: 100%;
    padding: 0;
}
.speed-slider:hover {
    opacity: 1;
}


/* Dropdown menu and items. */
.tooltip {
    display: inline-block;   
    position: relative;
}
.tooltip-content {
    display: none;
    position: absolute;
    width: max-content;
    left:40px;
    top:-30px;
    z-index: 1;
    background-color: white;
    color: orange;
    border-style: solid;
    border-color: orange;
    border-width: 1px;
    border-radius: 10px;
    padding: .2em 2em .2em 2em;
    margin-bottom: .5em;
    box-shadow: 3px 6px 5px rgba(0, 0, 0, 0.3);
    line-height: 1.0;
}
.tooltip:hover .tooltip-content {
    display: block;
}

</style>


</head>
<body onload="main()" onresize="resize_area()">

    <table class="page">

        <tr id="header">
            <td colspan="2">
                <div class='card-rounded grad-blue middle space-between'>

                    <div>
                        <h1 class="teal">Quantized Energy Behavior From Waves</h1>
                    </div><br><br>
                    <div>
                        <!-- Trigger to Open the Modal -->
                        <button onclick="document.getElementById('help-page').style.display='block'">Help</button>
                        <button onclick="document.getElementById('details-page').style.display='block'">Details</button>        
                        <button onclick="document.getElementById('about-page').style.display='block'">About</button>
                    </div>

                    <div id="help-page" class="modal card-rounded grad-gold">
                        <div class="modal-header middle space-between">
                            <h2>Help</h2>
                            <div>
                                <button onclick="document.getElementById('help-page').style.display='none'">Close</button>
                            </div>
                        </div>
                        <div class="modal-scroll">
                            <pre>
    SETUP:
	Size:   Width and height seperated by any non numeric
                character.

        Mode:
            *   Gradient – Colors represent the length of the
                    gradient of the field.
            *   Amplitude – Colors represent positive and negative
                    deflection from zero.
            *   Momentum – Colors represent differnce of
                    amplitude from previous frame.
            *   Acceleration – Colors represent the force acting on
                    the amplitude from the surrounding field.

        Edge:
            *   Reflect – Edges reflect values near them.
            *   Wrap – Edges get values from opposite side.
            *   Rounded – Locations further than a radius from the
                    center of each side are set zero.

        Seed:   Seed for random number generator used to produce
                image.

        Reset Image Button:  Reset image by current seed value.

        Random Image Button:  Pick a random seed value and
                produce a new image.

    FORMULA:
	*   Sigma   Radius of Gaussian kernal
	*   C1  Constant1, Larger values reduce the effect of the
                    other variables.
	*   E1  Exponent1, applied to amplitude change velocity. 
	*   C2  Constent2, Tension pivot value.
	*   E2  Exponent2, applied to adjusted amplitude term.
        
        Reset Values Button: Restore values to initial state.
        
        Random Values Button: Try random values.
            
    SPEED:
        *   Adjust the speed of the simulation.
        *   &lt;&lt;  Reverse direction of waves.
        *   #   Pause
        *   >>  Forward direction of waves.

        Notes:
            + Screen refresh and simulation speed interaction
              acts similar to a strobe light.
            + While simulation is paused array pointer displays
              array coordinate position.

    SCALE:
        *   Set the upper limit of the amplitude the color values
            are based on.
        Notes:
            + A dark screen results if the upper limit is
              significantly above the average values.
            + A light screen results if the upper limit is near
              or below the average values.

    Copy Values Button:  Copy current values to the clip board as text,

    Copy URL+Values Button:   Copy current values as a URL to the clip board
                for sharing.

    Full Screen Button:  Switch to full screen mode.  (Use escape to exit.)
  
    KEYBOARD COMMANDS:
	*   Space   Pause/Play
	*   Q       Random Values
        *   R       Reset Values
        *   1       Gradient Length Mode
        *   2       Amplitude Mode
        *   3       Momentum (Amplitude change)
        *   4       Acceleration (Amplitude acceleration force)
        *   Escape  Exit Full Screen.
                            </pre>
                               
                        </div>
                    </div>
                    
                    <div id="details-page" class="modal card-rounded grad-gold">
                        <div class="modal-header middle space-between">
                            <h2>Detailed Information</h2>
                            <div>
                                <button onclick="document.getElementById('details-page').style.display='none'">Close</button>
                            </div>
                        </div>
                        <div class="modal-scroll">
                            <pre>
    Detailed Information on how it works and why
    will go here.
                            </pre>
                        </div>
                    </div>
                </div>
                    
                <div id="about-page" class="modal card-rounded grad-gold">
                    <div class="modal-header middle space-between">
                        <h2>Quantized Energy Behavior From Waves</h2>
                        <div>
                            <button onclick="document.getElementById('about-page').style.display='none'">Close</button>
                        </div>
                    </div>
                    <div class="modal-scroll middle">
                        <div style="display: block; width: 100%; text-align: center;">

                            <h1>Quantized Energy Behavior From Waves</h1>

                            <p>
                                A simulation to explore and demonstrate a<br>
                                mechanism for energy to quantify from waves.
                            </p>
                            <p>
                                Version-1.0-9<br>
                                Date: 12/28/2021<br>
                                Copyright 2021 Ronald R. Adam
                            </p>
                            <div id="contact" onMouseOver="contact()">Contact</div>
                            <script>
function contact(){
    var p1 = "ron" + 32 * 5 * 20
    var p2 = Math.pow(2,6)
    var p3 = String.fromCharCode(p2)
    var p4 = "gmail.com"
    var p5 = p1 + String.fromCharCode(p2) + p4
    var el = document.getElementById('contact')
    el.innerHTML = "Please send email to: <a href=" + "mai" + "lto" + ":" + p5 + ">" + p1 + p3 + p4 + "</a>"
}
                            </script>
                            
                        </div>
                    </div>
                </div>

            </td>
        </tr>



<tr id="main-content">
    <td id='column1' class="fit-width">
        
        <div class="card-rounded grad-grey small">
            <span class="tab14 green">Array Size:</span>
            <div class="tooltip">
                <input id="grid-size"
                       size="10"
                       value='256, 256'
                       onchange="set_grid_size(this.value)">
                <div class="tooltip-content">width, height</div>
            </div> 
            <br>
            <span class="tab14 green">Display Mode:</span>
            <div class="dropdown outline">
                <label id="Mode">Gradient</label>
                <div class="dropdown-content card-square">
                    <div class="dropdown-item" onMouseUp="set_display_mode(0)">Gradient</div>
                    <div class="dropdown-item" onMouseUp="set_display_mode(1)">Amplitude</div>
                    <div class="dropdown-item" onMouseUp="set_display_mode(2)">Momentum</div>
                    <div class="dropdown-item" onMouseUp="set_display_mode(3)">Acceleration</div>         
                </div>
            </div>
            <br>
            <span class="tab14 green">Edge Mode:</span>
            <div class="dropdown outline">
                <label id="Edge">Reflect</label>
                <div class="dropdown-content card-square">
                    <div class="dropdown-item" onMouseUp="set_edge_mode(0);">Reflect</div>
                    <div class="dropdown-item" onMouseUp="set_edge_mode(1);">Wrap</div>
                    <div class="dropdown-item" onMouseUp="set_edge_mode(2);">Rounded</div>
                </div>
            </div>
            <br>
            <span class="tab14 green">Image Seed:</span>
            <input id="Seed" type="text" size="10"
                   onchange="set_seed(parseInt(this.value))"><br>
            <div class="col space-left">
                <button onMouseUp="set_image()">Reset Image</button>          
                <button onMouseUp="random_image()">Random Image</button>
            </div>
        </div>
        
        <div class="card-rounded grad-grey small">
            <span class="green">Formula:</span>
            <br>
            <div style="padding-left: 2em; line-height: 2.0;">
                1.&nbsp;&nbsp;g = gaussian(u,
                <div class="tooltip">               
                    <input id="Sigma"
                           type="text" size="4"
                           onchange="set_value(this.id, parseFloat(this.value))"
                           name="Sigma">)
                    <div class="tooltip-content">Sigma</div>
                </div>
                <br>
                2.&nbsp;&nbsp;a = g - u
                <br>
                3.&nbsp;&nbsp;m = u - u1
                <br>
                4.&nbsp;&nbsp;w = u + a + m
                <br>
                5.&nbsp;&nbsp;r =
                <div class="tooltip">                
                    <input id="C1"
                           type="text" size="6"
                           onchange="set_value(this.id, parseFloat(this.value))"
                           name="C1"/>
                    <div class="tooltip-content">C1</div>
                </div>
                + |m + a|^
                <div class="tooltip">
                    <input id="E1"
                           type="text" size="3"
                           onchange="set_value(this.id, parseFloat(this.value))"
                           name="E1">
                    <div class="tooltip-content">E1</div>
                </div>
                <br>
                
                <div class="row middle">
                    <div class="col">
                        6.&nbsp;&nbsp;fb = &nbsp; &nbsp;
                    </div>
                    <div class="col fit-content">
                        <div class="row center">
                            (r + 
                            <div class="tooltip">
                                <input id="C2"
                                       type="text" size="4"
                                       onchange="set_value(this.id, parseFloat(this.value))"
                                       name="C2">
                                <div class="tooltip-content">C2</div>
                            </div>
                            )
                        </div>
                        <hr style="margin:0; padding:0;">                   
                        <div class="row">
                            (r + |u + a - m/r|^
                            <div class="tooltip">
                                <input id="E2"
                                       type="text" size="3"
                                       onchange="set_value(this.id, parseFloat(this.value))"
                                       name="E2">
                                <div class="tooltip-content">E2</div>
                            </div>
                            )
                        </div>
                    </div>
                </div>
                7. A = fb * w
                <div class="space-left">
                    <button onMouseUp="reset_values()">Reset Values</button>
                    <button onMouseUp="random_values()">Random Values</button>
                </div>
            </div>
        </div>
        
        <div class="card-rounded grad-grey small">
            <div class="row space-between">
                <div class="col">
                    <span class="green">Speed: </span>
                    <span class="tab10">
                        <input id="Speed" type="text" size="5" onchange="set_speed(parseFloat(this.value))">
                    </span>
                </div>
                <div class="col small">
                    <button id="Reverse" onMouseUp="reverse()"><b>&lt;&lt;</b></button>
                    <button id="Pause" onMouseUp="pause()"><b>&nbsp;#&nbsp;</b></button>
                    <button id="Forward" onMouseUp="forward()"><b>&gt;&gt;</b></button>
                </div>
            </div>
            <input  id="speed_slider" class="speed_slider" type="range" min="0" max="10000"
                    value="0" onMouseUp="set_speed_from_slider(this.value)">
            <script>
                var speed_slider = document.getElementById("speed_slider");
                speed_slider.oninput = function() {
                set_speed_from_slider(speed_slider.value)
                }
            </script>
        </div>

        <div class="card-rounded grad-grey small">
            <span class="green">Amplitude Scale:</span>
            <input id="Scale" type="text" size="5" onchange="set_scale(parseFloat(this.value))"><br>
            <input id="scale_slider"
                   class="speed_slider"
                   type="range" min="0" max="1000"
                   value="0"
                   onMouseUp="set_scale_from_slider(this.value)">
            <script>
                var scale_slider = document.getElementById("scale_slider");
                scale_slider.oninput = function() {
                set_scale_from_slider(scale_slider.value)
                }
            </script>
        </div>

    </td>  <!-- End column 1 -->

    
    <td id="column2" class="fit-rest">
        <div id="canvas-container" class="canvas-container">
            <div id="canvas-area" class="canvas-area">
                <div id="coords" class="coords green">x, y</div>
                <canvas id="canvas" class="canvas"
                        onmousemove="onMouseMove(event)"
                        onmouseleave="onMouseLeave()">
                </canvas>
                <script>
                    function onMouseLeave(){
                        document.getElementById('coords').style.display = 'none'
                        document.getElementById('canvas').style.cursor = 'default'                    
                    }
                    
                    function onMouseMove(e){
                        var coord_div = document.getElementById('coords')
                        var ca = document.getElementById('canvas-area')
                        if (VALUES["Animating"]==0){                           
                            var rect = ca.getBoundingClientRect()
                            var aw = ca.clientWidth
                            var ah = ca.clientHeight
                            var mx = (e.x - rect.left) //mouse pos
                            var my = (e.y - rect.top)  //mouse ops
                            var cw = VALUES['Width']
                            var ch = VALUES['Height']
                            var x = mx/aw * cw
                            var y = my/ah * ch
                            
                            if (aw/ah > cw/ch){
                                // Window wider than canvas,
                                // scale to width - left padding.
                                var w = cw/ch * ah
                                var pad = (aw/w * cw - cw)/2
                                x = mx/w * cw - pad
                                // y is ok
                            }else{
                                // Window taller than canvas,
                                // scale to height - top padding.
                                var h = ch/cw * aw
                                var pad = (ah/h * ch - ch)/2                                
                                y = my/h * ch - pad
                                // x is ok
                            }
                            if (x>=0 && x<=cw && y>=0 && y<=ch) {
                                if (e.x > rect.right - 80) {
                                    coord_div.style.left = e.x - 75 + 'px' 
                                } else {
                                    coord_div.style.left = e.x + 16 + 'px' 
                                }
                                if (e.y > rect.bottom - 35) {
                                    coord_div.style.top = e.y - 32 +'px'
                                } else {
                                    coord_div.style.top = e.y + 16 +'px' 
                                }
                                coord_div.innerHTML = x.toFixed(0)+", "+y.toFixed(0)
                                coord_div.style.display = 'block'
                                canvas.style.cursor = 'crosshair'
                            }else{
                                coord_div.style.display = 'none'
                                canvas.style.cursor = 'default'
                            }
                        }
                    }
                </script>                
            </div> 
        </div>
    </td>  <!-- End column 2 -->

</tr>  <!-- End main content row -->

<tr id="footer">
    <td colspan='2'>
        <div class="card-rounded grad-blue small space-between middle">
            <div>
                <span>Copyright 2021 by Ronald Adam</span>&nbsp;&nbsp;
                <span class="tab14">Version: 1.0</span>
            </div>
            <div>
                <div class="tab16">Video FPS: <span id="video_frame_rate" style="color:#0000a0"> 0 </span></div>
                <div class="tab16">Sim. FPS: <span id="sim_frame_rate" style="color:#0000a0"> 0 </span></div> 
                <div class="tab16">Frame #: <span id="FrameCount" style="color:#0000a0"> 0 </span></div>
            </div>
            <div>
                <button onclick="copy_url()">Copy URL+Values</button>      
                <button onclick="copy_values()">Copy Values</button>
                <button onclick="document.getElementById('canvas').requestFullscreen()"> Full Screen </button>
            </div>
        </div>
    </td>
</tr>
    </table>
</body>
</html>
