<!DOCTYPE html>
<html lang="en">
    
<head>
    <title>Emergent Behaviors In Waves</title>
    <meta http-equiv="content-type"
          content="text/html; charset=utf-8">
    <meta name="author"
          content="Ronald Adam" >
    <meta name="description"
          content="Emergent Behaviors In Waves, Simulation #1.">
    <meta name="keywords"
          content="relativity, quantum, gaussian, simulation, wave, particle, feedback, phase, vortex" >
    <meta name="viewport"
          content="width=device-width, initial-scale=1">



<script>   
/* ---- WEBGL SHADERS ----------------------- */

// Functions to be inserted into shaders.

const gaussian_sample = `
vec4 gaussian_sample(sampler2D sampler, vec2 texCoord, float sigma){
    vec2 texSize = vec2(textureSize(sampler, 0));
    vec2 TC = texCoord;

    // Sample sides of expanding square, stop when values are low.
    // Add center first.
    vec4 G = texture(sampler, TC);    // Center always counted.
    float kweight = 1.0;              // Count of samples.

    float m2ss = -2.0 * sigma * sigma;
    int r = 1;              // Radius of kernel.
    float k = 1.0;          // Kernel value at pixel.
    float dist = 0.0;
    while (true) {
        // Find k for this distance.
        //Stays the same till next loop.
        dist = float(abs(r));
        k = exp(dist * dist / m2ss);  // Gaussian curve
        if (k<0.1) {
            break;
        }
        float rtx = float(r)/texSize.x;
        float rty = float(r)/texSize.y;
        G += texture(sampler, TC + vec2( rtx, 0.0)) * k;
        G += texture(sampler, TC + vec2(-rtx, 0.0)) * k;
        G += texture(sampler, TC + vec2( 0.0,-rty)) * k;
        G += texture(sampler, TC + vec2( 0.0, rty)) * k;
        kweight += k * 4.0;
        // Get off center side values along a side.
        for (int dx=1; dx<r; dx++) {
            dist = length(vec2(dx, r));
            k = exp(dist * dist / m2ss);
            if (k<0.1) break;
            float dxt = float(dx)/texSize.x;
            float dyt = float(dx)/texSize.y;
            vec4 sides = texture(sampler, TC + vec2( dxt, rty));
            sides += texture(sampler, TC + vec2(-dxt, rty));
            sides += texture(sampler, TC + vec2( rtx, dyt));
            sides += texture(sampler, TC + vec2( rtx,-dyt));
            sides += texture(sampler, TC + vec2( dxt,-rty));
            sides += texture(sampler, TC + vec2(-dxt,-rty));
            sides += texture(sampler, TC + vec2(-rtx, dyt));
            sides += texture(sampler, TC + vec2(-rtx,-dyt));
            G += sides * k;
            kweight += k * 8.0;
        }
        // Get corner values.
        dist = length(vec2(r, r));
        k = exp(dist * dist / m2ss);
        if (k>0.1) {
            G += texture(sampler, TC + vec2( rtx,  rty)) * k;
            G += texture(sampler, TC + vec2( rtx, -rty)) * k;
            G += texture(sampler, TC + vec2(-rtx, -rty)) * k;
            G += texture(sampler, TC + vec2(-rtx,  rty)) * k;
            kweight += k * 4.0;
        }
        r += 1;
    }
    G /= kweight;
    return G;
}
`

const gaussian_gradient_sample = `
vec4 gaussian_gradient_sample(sampler2D sampler, vec2 texCoord, float sigma){
    vec2 texSize = vec2(textureSize(sampler, 0));
    vec2 TC = texCoord;

    // Sample sides of expanding square, stop when values are low.
    // Add center first.
    vec4 G = gradient_sample(sampler, TC);    // Center always counted.
    float kweight = 1.0;                      // Count of samples.

    float m2ss = -2.0 * sigma * sigma;
    int r = 1;              // Radius of kernel.
    float k = 1.0;          // Kernel value at pixel.
    float dist = 0.0;
    while (true) {
        // Find k for this distance.
        //Stays the same till next loop.
        dist = float(abs(r));
        k = exp(dist * dist / m2ss);  // Gaussian curve
        if (k<0.1) {
            break;
        }
        float rtx = float(r)/texSize.x;
        float rty = float(r)/texSize.y;
        G += gradient_sample(sampler, TC + vec2( rtx, 0.0)) * k;
        G += gradient_sample(sampler, TC + vec2(-rtx, 0.0)) * k;
        G += gradient_sample(sampler, TC + vec2( 0.0,-rty)) * k;
        G += gradient_sample(sampler, TC + vec2( 0.0, rty)) * k;
        kweight += k * 4.0;
        // Get off center side values along a side.
        for (int dx=1; dx<r; dx++) {
            dist = length(vec2(dx, r));
            k = exp(dist * dist / m2ss);
            if (k<0.1) break;
            float dxt = float(dx)/texSize.x;
            float dyt = float(dx)/texSize.y;
            vec4 sides = gradient_sample(sampler, TC + vec2( dxt, rty));
            sides += gradient_sample(sampler, TC + vec2(-dxt, rty));
            sides += gradient_sample(sampler, TC + vec2( rtx, dyt));
            sides += gradient_sample(sampler, TC + vec2( rtx,-dyt));
            sides += gradient_sample(sampler, TC + vec2( dxt,-rty));
            sides += gradient_sample(sampler, TC + vec2(-dxt,-rty));
            sides += gradient_sample(sampler, TC + vec2(-rtx, dyt));
            sides += gradient_sample(sampler, TC + vec2(-rtx,-dyt));
            G += sides * k;
            kweight += k * 8.0;
        }
        // Get corner values.
        dist = length(vec2(r, r));
        k = exp(dist * dist / m2ss);
        if (k>0.1) {
            G += gradient_sample(sampler, TC + vec2( rtx,  rty)) * k;
            G += gradient_sample(sampler, TC + vec2( rtx, -rty)) * k;
            G += gradient_sample(sampler, TC + vec2(-rtx, -rty)) * k;
            G += gradient_sample(sampler, TC + vec2(-rtx,  rty)) * k;
            kweight += k * 4.0;
        }
        r += 1;
    }
    G /= kweight;
    return G;
}
`

const gradient_sample = `
vec4 gradient_sample(sampler2D sampler, vec2 texCoord) {
    // Gradient Magnatude is returned.
    vec2 texSize = vec2(textureSize(sampler, 0));
    float Dx = 1.0 / texSize.x;
    vec4 vx = (texture(sampler, texCoord + vec2(Dx, 0.0)) - texture(sampler, texCoord - vec2(Dx, 0.0)))/2.0;
    float Dy = 1.0 / texSize.y;
    vec4 vy = (texture(sampler, texCoord + vec2(0.0, Dy)) - texture(sampler, texCoord - vec2(0.0, Dy)))/2.0;
    return vec4(length(vec2(vx.r, vy.r)),
                length(vec2(vx.g, vy.g)),
                length(vec2(vx.b, vy.b)),
                length(vec2(vx.a, vy.a)));
}
`


const mpolate = `
float mpolate(float A, float B, float C, float t) {
    //
    //  Smoothly interpolate over time from the midpont
    //  between AB to the midpoint BC.
    //  Value t is position between 0 and 1.
    //
    float t1 = (1.0 - t) * (1.0 - t);
    float L1 = (B - A) * t1;
    float t2 = t * t;
    float L2 = (B - C) * t2;
    return B - (L1 + L2) / 2.0;
}
`
    
// VERTEX SHADERS
const VS_points = `#version 300 es
layout(location = 0) in vec2 aPos;
layout(location = 1) in vec2 aTexCoord;
out vec2 vTexCoord;
void main(void) {
   vTexCoord = aTexCoord;
   gl_Position = vec4(aPos, 0.0, 1.0);
}
`;


// CALCULATION SHADER
const FS_calc = `#version 300 es
precision highp float;
uniform highp sampler2D uSampler;
uniform int   uEdge;
uniform float uSigma;
uniform float uC1;
uniform float uE1;
uniform float uC2;
uniform float uE2;

in vec2 vTexCoord;
out vec4 fragColor4;

${gaussian_sample}

void main(void) {
    vec2 TC = vTexCoord;
    if ((uEdge == 2) && (length(TC - 0.5) > 0.48)) {
       // If edge mode is circular and point outside a circle, skip it.
       discard;
    }
    vec4 y = texture(uSampler, TC);
    float U = y.a;
    float V = y.b;
    float m = U - V;    
    float G = gaussian_sample(uSampler, TC, uSigma).a;
    float a = G - U;
    float w = U + a + m;
    float v = uC1 + pow(abs(m + a), uE1);
    float fb = (v + uC2) / (v + pow(abs(U + a - m/v), uE2));
    fragColor4 = vec4(y.g, y.b, y.a, w * fb);
}
`;


// DISPLAY SHADER
const FS_draw = `#version 300 es
precision highp float;
uniform highp sampler2D uSampler;
uniform sampler2D uColor1;
uniform sampler2D uColor2;
    
uniform float uFrameTime;
uniform float uScale;
uniform int uMode;
uniform int uEdge;
uniform float uSigma;
    
in vec2 vTexCoord;
out vec4 fragColor4;

${gaussian_sample}
${gradient_sample}
${gaussian_gradient_sample}
${mpolate}

void main(void) {
    vec2 texSize = vec2(textureSize(uSampler, 0));
    vec2 TC = vTexCoord;

    if (uEdge == 2 && (length(TC - 0.5) > .49)) {
       discard;
    }

    if (uMode == 0) {
        // Gradient of amplitude.   
        vec4 y = gradient_sample(uSampler, TC);
        float v = mpolate(y.a, y.b, y.g, 1.0 - uFrameTime);
        v = clamp(v/uScale, 0.0, 1.0);
        v = (v < 0.5) ? pow(v * 2.0, 0.5)/2.0 : pow((v - 0.5) * 2.0, 2.0)/2.0 + 0.5;
        fragColor4 = texture(uColor1, vec2(v, 0.0));
    }
    else if (uMode == 1) {    
        // Amplitude.
        vec4 y = texture(uSampler, TC);    
        float v = mpolate(y.a, y.b, y.g, 1.0 - uFrameTime);
        v = clamp(0.5 + v/uScale * 0.5, 0.0, 1.0);
        fragColor4 = texture(uColor2, vec2(v, 0.0));
    }
    else if (uMode == 2) {
        // Momentum of amplitude.
        vec4 y = texture(uSampler, TC);
        float a1 = mpolate(y.b, y.g, y.r, 1.0 - uFrameTime);   
        float a2 = mpolate(y.a, y.b, y.g, 1.0 - uFrameTime);
        float v = (a1 - a2);
        v = clamp(0.5 + v/uScale * 0.5, 0.0, 1.0);
        fragColor4 = texture(uColor2, vec2(v, 0.0));   
    }
    else if (uMode == 3) {
        // Acceleration of amplitude.
        vec4 gy = gaussian_sample(uSampler, TC, uSigma);
        vec4 ty = texture(uSampler, TC);
        vec4 dy = gy - ty;   // Acceleration force.
        float v = mpolate(dy.b, dy.g, dy.r, 1.0 - uFrameTime);
        v = clamp(0.5 + v/uScale * 0.5, 0.0, 1.0);
        v = (v < 0.5) ? pow(v * 2.0, 0.5)/2.0 : pow((v - 0.5) * 2.0, 2.0)/2.0 + 0.5;
        fragColor4 = texture(uColor2, vec2(v, 0.0));
    }
}`;


// Used to copy render buffer back to calc buffer,
// and to render to an Javascript array.
const FS_copy = `#version 300 es
precision highp float;
uniform highp sampler2D uSampler;
in vec2 vTexCoord;
out vec4 fragColor4;
void main(void) {
    precision highp float;
    fragColor4 = texture(uSampler, vTexCoord);
}`;


// Reverse colors values to swap directioin. (rgba --> abgr>
const FS_swap = `#version 300 es
precision highp float;
uniform highp sampler2D uSampler;
in vec2 vTexCoord;
out vec4 fragColor4;
void main(void) {
    precision highp float;
    vec4 c = texture(uSampler, vTexCoord);
    fragColor4 = vec4(c.a, c.b, c.g, c.r);
}`;
    

/* ---- JAVASCRIPT PROGRAM ------- */

// Values that can be changed though both
// the URL and page interactions.
const VALUES = {"Sigma":2,
                "C1":2,
                "E1":2,
                "C2":0.5,
                "E2":2,
                "Width":256,
                "Height":256,
                "Edge":0,       // 0:Reflect
                "Mode":0,       // 0:Gradient
                "Scale":4,
                "Speed":4,
                "Direction":1,  // -1:reverse 1:forward
                "Animating":0,  // 0:false, 1:true
                "FrameCount":0,
                "FrameTime":0,
                "Seed":0,
               }

// Catagories for response.
const MODE = ["Gradient", "Amplitude", "Momentum", "Acceleration"]
const EDGE = ["Reflect", "Wrap", "Rounded"]
const UNIFORMS = new Set(["Sigma", "C1", "E1", "C2", "E2", "uE2"])

//  CREATE COLOR LUT
const ColorLUT1 = new Uint8Array([
      0,   0,   0, 255,
      0,   0, 255, 255,
      0, 100, 255, 255,
    255, 255, 255, 255,        
]);
    
const ColorLUT2 = new Uint8Array([            
    255, 100, 100, 128,
    255, 0,   0,   255, 
    0,   0,   0,   255,
    0,   0,   255, 255,
    100, 100, 255, 128,
]);
    


var canvas, gl, prog_draw, prog_calc, prog_swap, prog_render,
    texture0, texture1, colorlut;

// Enables reapeatable starting conditions.
Math.seed = 0
Math.seededRandom = function(max, min){
    max = max || 1;
    min = min || 0; 
    Math.seed = (Math.seed * 9301 + 49297) % 233280;
    var rnd = Math.seed / 233280;
    return (min + rnd * (max - min));
}


// Used frequently.  
function set_uniform_1i(program, name, value){
    gl.useProgram(program)
    Loc = gl.getUniformLocation(program, name)
    gl.uniform1i(Loc, value)
}

function set_uniform_1f(program, name, value){
    gl.useProgram(program)
    Loc = gl.getUniformLocation(program, name)
    gl.uniform1f(Loc, value)
}


function main() {
    canvas = document.getElementById("canvas")
    
    set_values_from_url()  // If any.
     
    // Size is be reset later.
    canvas.width = VALUES["Width"]
    canvas.height = VALUES["Height"]

    var err = "Your browser does not support "
    if (!window.WebGLRenderingContext) {
        alert(err + "WebGL. See http://get.webgl.org")
        return none
    }
    try {
        gl = canvas.getContext("webgl2")
    } catch (e) {}
    if (!gl) {
        alert("Can't get WebGL 2");
        return none
    }

    var ext
    try {
        ext = gl.getExtension("EXT_color_buffer_float");
    } catch (e) {}
    if (!ext) {
        alert(err + "EXT_color_buffer_float");
        return;
    }

    var aPosLoc = 0
    var aTexLoc = 1

    var VS = createShader(gl, gl.VERTEX_SHADER, VS_points)
    gl.enableVertexAttribArray(aPosLoc)
    gl.enableVertexAttribArray(aTexLoc)
    var data = new Float32Array(
        [-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1])
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())    
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)
    gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, gl.FALSE, 16, 0)
    gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, gl.FALSE, 16, 8)

    prog_draw = gl.createProgram()
    gl.attachShader(prog_draw, VS)
    gl.attachShader(prog_draw, createShader(gl, gl.FRAGMENT_SHADER, FS_draw))
    gl.bindAttribLocation(prog_draw, aPosLoc, "aPos")
    gl.bindAttribLocation(prog_draw, aTexLoc, "aTexCoord")
    gl.linkProgram(prog_draw)

    prog_calc = gl.createProgram()
    gl.attachShader(prog_calc, VS)
    gl.attachShader(prog_calc, createShader(gl, gl.FRAGMENT_SHADER, FS_calc))
    gl.bindAttribLocation(prog_calc, aPosLoc, "aPos")
    gl.bindAttribLocation(prog_calc, aTexLoc, "aTexCoord")
    gl.linkProgram(prog_calc)

    prog_swap = gl.createProgram()
    gl.attachShader(prog_swap, VS)
    gl.attachShader(prog_swap, createShader(gl, gl.FRAGMENT_SHADER, FS_swap))
    gl.bindAttribLocation(prog_swap, aPosLoc, "aPos")
    gl.bindAttribLocation(prog_swap, aTexLoc, "aTexCoord")
    gl.linkProgram(prog_swap)

    prog_render = gl.createProgram()
    gl.attachShader(prog_render, VS)
    gl.attachShader(prog_render, createShader(gl, gl.FRAGMENT_SHADER, FS_copy))
    gl.bindAttribLocation(prog_render, aPosLoc, "aPos")
    gl.bindAttribLocation(prog_render, aTexLoc, "aTexCoord")
    gl.linkProgram(prog_render)

    set_grid_size(`${VALUES["Width"]}, ${VALUES["Height"]}`)  
    
    

    // Define color table2.
    var width = 4;
    var height = 1;
    var texture = gl.createTexture()
    gl.activeTexture(gl.TEXTURE0 + 2)
    gl.bindTexture(gl.TEXTURE_2D, texture)
    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, width, height)
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, ColorLUT1)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
    set_uniform_1i(prog_draw, "uColor1", 2)
    
    // Define color table2.
    var width = 5;
    var height = 1;
    var texture = gl.createTexture()
    gl.activeTexture(gl.TEXTURE0 + 3)
    gl.bindTexture(gl.TEXTURE_2D, texture)
    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, width, height)
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, ColorLUT2)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)    
    set_uniform_1i(prog_draw, "uColor2", 3)
    
    
    set_uniform_1i(prog_draw, "uSampler", 0)
    set_uniform_1i(prog_calc, "uSampler", 0)
    set_uniform_1i(prog_swap, "uSampler", 0)
    set_uniform_1i(prog_render, "uSampler", 0)

    // Update info panel every half second.
    timer = setInterval(update_info, 500)

    // Key listener for display control.
    const box = document.querySelector(".canvas")
    document.addEventListener("keydown", e => {
        if (e.target.id=='' && e.keyCode==32){
            if (VALUES["Animating"]){
                pause()
            }else if (VALUES['Direction']>0){
                forward()
            }else{
                reverse()
            }
        }
        if (e.keyCode== 82){
            random_values()
        }
    })
    
    reset_values()
    pause()
    animate()
}

function createShader(gl, type, source){
    var shader = gl.createShader(type)
    gl.shaderSource(shader, source)
    gl.compileShader(shader)
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        return shader
    console.log(gl.getShaderInfoLog(shader))
    gl.deleteShader(shader)
}

function set_grid_size(size){
    // A string is needed for 'size'.  "width, hieght".
    var xysize = []
    var W, H
    try {
        xysize = size.replace('?:[^0-9]', ' ').split(' ')
        W = parseInt(xysize[0])
        H = parseInt(xysize[1])
    } catch (e) {}
    if (!W || !H) {
        alert("invlid width and height values")
        return none
    }

    VALUES["Width"] = W
    VALUES["Height"] = H
    canvas.width = W
    canvas.height = H
    
    document.getElementById("grid-size").value = `${W}, ${H}`

    texture0 = gl.createTexture()
    set_texture(texture0, 0, [])
    
    FBO = gl.createFramebuffer()
    gl.bindFramebuffer(gl.FRAMEBUFFER, FBO)
    gl.viewport(0, 0, W, H);
    gl.framebufferTexture2D(gl.FRAMEBUFFER,
                            gl.COLOR_ATTACHMENT0,
                            gl.TEXTURE_2D,
                            texture0,
                            0)
                           
    texture1 = gl.createTexture()
    set_texture(texture1, 0, [])
    
    FBO1 = gl.createFramebuffer()
    gl.bindFramebuffer(gl.FRAMEBUFFER, FBO1)
    gl.viewport(0, 0, W, H);
    gl.framebufferTexture2D(gl.FRAMEBUFFER,
                            gl.COLOR_ATTACHMENT0,
                            gl.TEXTURE_2D,
                            texture1,
                            0)
                            
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE)
        alert("FBOs are not complete")
        
    set_image()
}

function set_texture(texture, index, image) {
    var W = VALUES["Width"]
    var H = VALUES["Height"]
    gl.activeTexture(gl.TEXTURE0 + index)
    gl.bindTexture(gl.TEXTURE_2D, texture)
    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA32F, W, H)
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, W, H, gl.RGBA, gl.FLOAT, image)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
    set_edge_mode(VALUES["Edge"])
}

// FUNCTIONS USED IN ANIMATIOIN LOOP.
function copy_buffer() {
    // Copy FBO1 back to FBO.
    var W = VALUES["Width"]
    var H = VALUES["Height"]    
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, FBO1)   // Source.
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, FBO)    // Target.
    gl.blitFramebuffer(0, 0, W, H, 0, 0, W, H,
                       gl.COLOR_BUFFER_BIT, gl.NEAREST)
}

function step(){
    // Calculate from FBO to FBO1.
    gl.useProgram(prog_calc)
    gl.bindFramebuffer(gl.FRAMEBUFFER, FBO1)  // Target buffer
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    copy_buffer()
}

function swap_frames(){
    // Swap order of frames.  rgba --> abgr
    gl.useProgram(prog_swap)
    gl.bindFramebuffer(gl.FRAMEBUFFER, FBO1)  // Target buffer
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    copy_buffer()
}

function render() {
    // Used to copy the canvas to an array.
    gl.useProgram(prog_render)
    gl.bindFramebuffer(gl.FRAMEBUFFER, null)  // To screen.
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
}

function draw() {
    // Just Draw it.
    set_uniform_1f(prog_draw, "uFrameTime", VALUES["FrameTime"])
    gl.bindFramebuffer(gl.FRAMEBUFFER, null)
    //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4) 
}


// THE MAIN ANIMATION LOOP.
function animate(time_stamp) {
    if (VALUES["Animating"]) {
        FrameTime = VALUES["FrameTime"] + VALUES["Speed"]
        FrameCount = VALUES["FrameCount"]
        while (FrameTime >= 1.0) {
            step()
            FrameTime -= 1.0
            FrameCount += VALUES['Direction']
            if (FrameCount == 0) {
                pause()
                FrameTime = 0.0;
                break;
            }
        }
        VALUES["FrameTime"] = FrameTime
        VALUES["FrameCount"] = FrameCount
    }
    draw()
    video_frames ++
    requestAnimationFrame(animate)
}


// Set and read values.
function set_display_mode(mode) {
    VALUES["Mode"] = mode
    var label = document.getElementById("Mode")
    label.innerHTML = MODE[mode]
    set_uniform_1i(prog_draw, "uMode", mode)
}

function set_edge_mode(mode) {
    VALUES["Edge"] = mode
    var edge_mode = EDGE[mode]
    var label = document.getElementById("Edge")
    label.innerHTML = edge_mode
    set_uniform_1i(prog_calc, "uEdge", mode)
    set_uniform_1i(prog_draw, "uEdge", mode)
    gl.activeTexture(gl.TEXTURE0 + 0)
    if (["Reflect", "Rounded"].includes(edge_mode)){
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT, gl.CLAMP_TO_EDGE)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT, gl.CLAMP_TO_EDGE)
    }else if (edge_mode=="Wrap"){
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT, gl.CLAMP_TO_EDGE)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT, gl.CLAMP_TO_EDGE)
    }
}

function random_values(){
    Math.seed = Date.now()
    set_value("Sigma", Math.seededRandom(1.0, 5.0).toPrecision(3))
    set_value("C1", Math.seededRandom(1.0, 20.0).toPrecision(3))
    set_value("C2", Math.seededRandom(0.1, 4.0).toPrecision(3))
    set_value("E1", Math.seededRandom(0.25, 3.0).toPrecision(3))
    set_value("E2", Math.seededRandom(0.25, 3.0).toPrecision(3))
    //set_image()
}

function set_image(){
    Math.seed = VALUES["Seed"]   
    var image = make_image()
    set_texture(texture0, 0, image)
    set_texture(texture1, 1, image)
    VALUES["FrameCount"] = 0
}

function random_image(){
    set_seed(Math.seed)
}

function set_seed(val){
    VALUES["Seed"] = val
    document.getElementById('Seed').value = val
    set_image()
}

function set_direction(d){
    if (VALUES["Direction"] != d){
        swap_frames()
        VALUES["Direction"] = d
    }
}

function forward(){
    document.getElementById("Forward").style.color = "red"
    document.getElementById("Pause").style.color = "black"
    document.getElementById("Reverse").style.color = "black"
    set_direction(1)
    VALUES["Animating"] = 1    
}

function reverse(){
    document.getElementById("Forward").style.color = "black"
    document.getElementById("Pause").style.color = "black"
    document.getElementById("Reverse").style.color = "red"
    set_direction(-1)
    VALUES["Animating"] = 1      
}

function pause(){
    document.getElementById("Forward").style.color = "black"
    document.getElementById("Pause").style.color = "red"
    document.getElementById("Reverse").style.color = "black"
    VALUES["Animating"] = 0
}

function set_speed_from_slider(value) {
    // Set speed from slider.
    var speed = Math.pow(value/10000, 2) * 100
    document.getElementById('Speed').value = speed.toFixed(3)
    document.getElementById('speed_slider').value = value
    VALUES["Speed"] = speed
}

function set_speed(s) {
    // Set speed from value.
    document.getElementById('Speed').value = parseFloat(s).toFixed(3)
    document.getElementById("speed_slider").value =  Math.sqrt(s/100) * 10000
    VALUES["Speed"] = s   
}

function set_scale_from_slider(value) {
    // Set scale from slider.
    var scale = Math.pow(value/1000, 2) * 50
    set_uniform_1f(prog_draw, "uScale", scale)
    document.getElementById('Scale').value = parseFloat(scale).toFixed(3)
    document.getElementById('scale_slider').value = value
    VALUES["Scale"] = scale.toFixed(3)
}

function set_scale(scale) {
    // Set scale from value.
    //scale = parseFloat(scale).toFixed(3) 
    set_uniform_1f(prog_draw, "uScale", scale)
    document.getElementById('Scale').value = parseFloat(scale).toFixed(3)
    document.getElementById('scale_slider').value = Math.sqrt(scale/50) * 1000
    VALUES["Scale"] = scale
}

// STATUS UPDATE FUNCTION.
var fps_timer = 0
var sim_frames = 0
var video_frames = 0

function update_info() {
    now = Date.now()
    count = VALUES["FrameCount"]
    var elapsed_time = now - fps_timer;
    var fps = Math.round(1000 * (count - sim_frames) / elapsed_time)
    document.getElementById("sim_frame_rate").innerHTML = fps
    fps = Math.round(1000 * video_frames / elapsed_time)
    document.getElementById("video_frame_rate").innerHTML = fps
    document.getElementById("FrameCount").innerHTML = count
    sim_frames = count   
    video_frames = 0    
    fps_timer = now
}

/*
//TODO: Work on this if it's needed. Just leaving this here for now.
    
function read_buffer(){
    var image = new Float32Array(4 * X * Y)
    var pixels = new Uint8Array(4 * X * Y);
    render()
    gl.readPixels(0, 0, X, Y, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    var x = 0
    while (x<pixels.length) {
        r = pixels[x]
        g = pixels[x+1]
        b = pixels[x+2]
        a = pixels[x+3]
        image[x]   = (r/256.0 - .5) * 8
        image[x+1] = (g/256.0 - .5) * 8
        image[x+2] = (b/256.0 - .5) * 8
        image[x+3] = (a/256.0 - .5) * 8
        x += 4
    }
    return image
}
*/

function make_image(){
    // Insert some pulses for the starting condition.
    var W = VALUES["Width"]
    var H = VALUES["Height"]
    var image = new Float32Array(4 * W * H)
    var n = Math.round(Math.seededRandom(2, 20))  // More doesn't help.
    for (var p=0; p<n; p++){
        // Insert a random pair.
        var h = Math.seededRandom(W/100, W/20)
        var psign = 1
        for (var k=0; k<2; k++){
            var t = 0
            var xpos = Math.seededRandom(W * 0.2, W * 0.8)
            var ypos = Math.seededRandom(W * 0.2, H * 0.8)
            for (var i=0; i<H; i++){
                for (var j=0; j<W; j++){
                    var x = (j - xpos)
                    var y = (i - ypos)
                    var d = Math.sqrt(x*x + y*y)
                    var w = gaussian(d, 1.0, 0.0, h) * psign
                    // Each color is a frame in time. r,g,b,a = t, t-1, t-2, t-3
                    image[t++] += w * 0.9
                    image[t++] += w
                    image[t++] += w
                    image[t++] += w * 0.9
                }
            }
            psign *= -1
        }
    }
    return image
}

function gaussian(x, a, b, sigma){
    // Find height y of x on gaussian curve,
    // scaled to amplitude a, with center of curve at b.
    var dist = x - b
    var y = a * Math.exp(-((dist * dist) / (2.0 * sigma * sigma)))
    return y
}

function read_values(){
    vals = ""
    for (var key in VALUES){
        vals += `${key}:${VALUES[key]} `
    }
    return vals
}

function copy_values() {
    var vals = read_values()
    navigator.clipboard.writeText(vals)
}

function copy_url(){
    var base_url = window.location.href.split('?')[0]
    var vals = "?"
    for (var key in VALUES) {
        vals += `${key}=${VALUES[key]}&`
    }
    navigator.clipboard.writeText(base_url + vals.slice(0, -1))
}
 
function open_url() {
    var url = window.location.href
    window.open(url);
}

function get_url_values() {
    var vals = {}
    var parts = window.location.href.split('?')
    if (parts.length<2) {
        return vals
    }
    var pairs = parts[1].split('&')
    for (const kvPair of pairs) {
        var pair = kvPair.split('=')
        vals[pair[0]] = pair[1]
    }
    return vals
}

function set_values_from_url() {
    // Call reset_values after this.
    // And after setting the texture size.
    var vals = get_url_values()
    for (id in VALUES) {
        if (id in vals){ 
            VALUES[id] = parseFloat(vals[id])
        }
    }
}

function reset_values() {
    set_grid_size(`${VALUES["Width"]}, ${VALUES["Height"]}`)
    for (id in VALUES) {
        set_value(id, VALUES[id]);
    }
}

function set_value(id, val){
    if (id in VALUES){
        if (UNIFORMS.has(id)){
            document.getElementById(id).value = val            
            val = parseFloat(val)
            set_uniform_1f(prog_calc, 'u'+id, val)
            if (id == "Sigma"){
                set_uniform_1f(prog_draw, 'u'+id, val)  //Used in both.              
            }
            VALUES[id] = val
        }else if (id == 'Edge'){
            set_edge_mode(val)
        }else if (id == 'Mode'){
            set_display_mode(val)
        }else if (id=="Scale"){
            set_scale(val)
        }else if (id=="Speed"){
            set_speed(val)
        }else if (id=="Forward"){
            forward()
        }else if (id=="Reverse"){
            reverse()
        }else if (id=="Puase"){
            pause()
        }else if (id=="Seed"){
            set_seed(val)
        }else{
            VALUES[id] = val
        }
    }else{
        console.log('unknown key:', id, val)
    }
}
</script>


<style>

/* Standard tags */
body {
    background-color: #d8d8dd;
    height: 100%;
    width: calc(100vw - 1.5em);
    padding: 0;
    margin: 0;
    
    /* let curser be changed */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    /* user-select: none; */
}

.page {
    width: 100%;
    padding: .5em;
    margin: 0;
    margin-right: 1em;  
}

h1 {
    margin: 0;
    padding: .25em;
}
h2 {
    margin: 0;
    padding: .5em;
    font-size: 1.5em;    
}
h3 {
    font-size: 1.25em;
    color: mediumblue;
}
h4 {
    display: inline-block;
    font-size: 1em;
    color: darkcyan;
    padding: 0 1em 0 0;
    margin: 0;
}
pre {
    background-color: white;
    color: black;
    font-size: 1em;
    font-family: "Lucida Console", Courier, monospace;
    border-width: 1px;
    border-radius: 9px;
    border-color: #bbbbbb;
    border-style: solid;
    padding: 1em;
}
button {
    display: inline-block;
    height: -moz-fit-content;
    height: fit-content;
    margin: .125em;
    padding: 0.125em .5em 0.125em .5em;
}
input {
    display: inline-block;
    color: #008;
    background-color: white;
    height: 1.5em;
    padding: 0 .25em 0 .25em;
    margin: .1em;
    border-style: solid;
    border-width: 1px;
    border-radius: 3px;
    border-color: grey;
}

/* Colors */
.grad-blue {
    background-image: linear-gradient(to bottom right, #ffffff, #ddddff, #f0f0f8);
    color: #066;
}
.grad-gold {
    color: #006;
    background-image: linear-gradient(to bottom right, #ffffff, #fffffe, #eeeeee);
}
.grad-grey {
    color: #006;
    background-image: linear-gradient(to bottom right, #ffffff, #eeeeee, #dddddd);
}
.green {
    color: green;
}
.teal {
    color: teal;
}

.outline {
    border-style: solid;
    border-width: 1px;
    border-radius: 3px;
    border-color: grey;
}

/* Fonts */
.small {
    font-size: small;
}
.medium {
    font-size: medium;
}

/* Content holders */
.header {
    padding: .5em 1em .5em 1em;
    margin: .5em;
}

.content {
    padding: .5em 1em .5em 1em;
    margin: .5em;
}

.footer {
    padding: .5em 1em .5em 1em;
    margin: .5em;
}


.card-square {
    padding: 0;
    margin: 0;
    border-style: solid;
    border-width: 1px;
    border-color: #888;
    box-shadow: 3px 6px 5px rgba(0, 0, 0, 0.3);
}

.card-rounded {
    padding: .5em 1em .5em 1em;
    margin: .25em;
    border-style: solid;
    border-width: 1px;
    border-radius: 7px;
    border-color: #aaaaaa;
    box-shadow: 5px 5px 7px rgba(0, 0, 0, 0.2);
}


/* Used for about information window. */
.modal {
    /* The Modal (background) */
    display: none;
    position: fixed;
    z-index: 2;
    left: calc(100% - 55em);
    top: 1em;
    width: 50em;
}
.modal-content {
    display: inline-block;
    background-color: #eeeeee;
    margin: 0;
    padding: .25em;
    border: 1px solid #888;
    width: auto;
}
.scroll {
    display: inline-block;
    background-color: #fafaf8;
    color: #003000;
    height: calc(100vh - 9em);
    width: auto;
    overflow-y: scroll;
    text-align: left;
    padding: 1em;
}
#about-text {
    display: inline-block;
    padding: 2ch;
    margin: 0;
}


.fit-width {
    /* fits width of conetent */
    display: grid;
    width: max-content;
}
.fit-rest {
    /* fits remaining width */
    display: table-cell;
    width: 100%; 
}


.space-between {
    display: flex;
    justify-content:space-between;
}
.space-left {
    display: flex;
    width: 100%;
    justify-content: flex-end;
}
.space-right {
    display: flex;
    width: 100%;
    justify-content: flex-start;
}

.center {
    width: 100%;
    display: flex;
    justify-content:center;
}
.middle {
    display: flex;
    align-items: center;
}

.indent2 {
    padding-left: 2ch;
    display: inline-block;
}

/* These define the width of a div or span.  */
.tab6 {
    width: 6ch;
    display: inline-block;
}
.tab8 {
    width: 8ch;
    display: inline-block;
}
.tab10 {
    width: 10ch;
    display: inline-block;
}
.tab14 {
    width: 14ch;
    display: inline-block;
}
.tab16 {
    width: 16ch;
    display: inline-block;
}
.tab24 {
    width: 24ch;
    display: inline-block;
}

/* Dropdown menu and items. */
.dropdown {
    display: inline-block;   
    position: relative;
    padding: 0 2em 0 2em;
    width: 8ch;
    margin: .2em;    
    color: #00a;
    background-color: #eef;
}
.dropdown-content {
    display: none;
    position: absolute;
    min-width: 10em;
    z-index: 1;
}
.dropdown:hover .dropdown-content {
    display: block;
}
.dropdown-item {
    display: block;
    padding: 0 1ch 0 1ch;
    color: #00a;
    background-color: #dde;
}
.dropdown-item:hover {
    background-color: lightgreen;
}


.coords {
    display: none;
    color: green;
    position:absolute;
    z-index:2;
    text-shadow: 1px 1px #000000;
}

.canvas_area {
    display: block;
    padding: 0;
    margin: 1em;  
}
.canvas {
    height: calc(100vh - 13em);
    width: 100%;
    object-fit: contain;
}


.speed_slider {
    width: 100%;
    padding: 0;
}
.speed-slider:hover {
    opacity: 1;
}


/* Dropdown menu and items. */
.tooltip {
    display: inline-block;   
    position: relative;
}
.tooltip-content {
    display: none;
    position: absolute;
    width: max-content;
    left:40px;
    top:-30px;
    z-index: 1;
    background-color: white;
    color: orange;
    border-style: solid;
    border-color: orange;
    border-width: 1px;
    border-radius: 10px;
    padding: .2em 2em .2em 2em;
    margin-bottom: .5em;
    box-shadow: 3px 6px 5px rgba(0, 0, 0, 0.3);
    line-height: 1.0;
}
.tooltip:hover .tooltip-content {
    display: block;
}

</style>


</head>
<body onload="main()">

    <table class="page">

        <tr>
            <td colspan="2">
                <div class='card-rounded grad-blue middle space-between'>

                    <div>
                        <h1 class="teal">Emergent Behaviors In Waves, Simulation #1.</h1>
                    </div>
                    <div>
                        <!-- Trigger to Open the Modal -->
                        <button onclick="document.getElementById('id01').style.display='help'">Help</button>
                        <button onclick="document.getElementById('id01').style.display='details'">Details</button>        
                        <button onclick="document.getElementById('id01').style.display='block'">About</button>
                    </div>

                    <!-- The Modal -->
                    <div id="id01" class="modal">
                        <div class="modal-content">
                            <div class="header middle space-between grad-gold card-rounded">
                                <div>
                                    <h2 class="medium teal">QLET - A BEHAVIOUR IN WAVES THAT QUANTIZES ENERGY.</h2>
                                </div>
                                <div>
                                    <button onclick="document.getElementById('id01').style.display='none'">Close</button>
                                </div>
                            </div>
                            <div class="content scroll card-rounded">
                                <h4>
                                    AUTHOR: RONALD R. ADAM<br>
                                    DATE:   12-5-2021
                                </h4>
                                <p>
                                    Welcome to my QLet 2D wave behavior explorer.  I created
                                    this project as an attempt to see if I could find particle
                                    like behaviors in waves.  The availability of fast computers
                                    with parallel graphic processors makes it possible to try
                                    many different formulations and see how they act.
                                </p>
                                <h4>THE GOAL:</h4> 
                                <p>
                                    To identify particle like wave behaviors
                                    in waves with feedback from the waves motion.
                                </p>
                                <br>

                                <h3>1. WHAT IS A QLET?</h3>
                                <p>
                                    A QLet is a name I'm using to describe the occurence of
                                    phase vortex's in 2D waves. Phase vortex's are currently
                                    being studied in optics and quantum physics.
                                </p>
                                <p>
                                    <a href="https://en.wikipedia.org/wiki/Quantum_vortex">Quantum Vortex</a><br>
                                    <a href="https://en.wikipedia.org/wiki/Optical_vortex#:~:text=Columns%20show%20the%20helical%20structures%2C%20phase-front%20and%20intensity,light%20that%20has%20such%20a%20zero%20in%20it.">
                                        Optical vortex</a>
                                </p>
                                <p>
                                    The term QLet is use here to describe the <b>behavior</b>
                                    of waves where they form phase vortex's.  So A QLet isn't
                                    an object as we normally think of them. It's a specific
                                    behavior, which has particle like relationships included
                                    with it, but isn't a full particle in it's self. It may
                                    be possible to identify such behaviors in other processes.
                                </p>
                                <p>
                                    Some of these behaviors include attraction, repelling, quantifying
                                    wave energy. They also combine with other QLets to form more
                                    complex forms.  They normally form in equal opposite spin
                                    pairs.
                                </p>
                                <p>
                                    There are some interesting behaviors regarding the phase
                                    of QLets.  The phase is maintained between the nearest
                                    QLets, and as the move around they exchange phase partners
                                    in a way that resembles dancing.
                                </p>
                                <p>
                                    The advantage of QLets as simulated here is that they can
                                    be easily produced and studied.
                                </p>
                                <br>

                                <h3>2. THE WAVE SIMULATION:</h3>
                                <p>
                                    In this simulation a wave is changing values in a smooth and
                                    continuous field.  Each point in the grid should be thought
                                    of as samples in the field at the location of the
                                    coordinates. The values between the coordinates will be a
                                    smooth curve connecting the grid points.
                                </p>
                                <p>
                                    The simulation always keeps the last four frames in memory.
                                    Only the two are needed for calculating the wave motion. The
                                    other two help with visualizing and interpreting the results.
                                </p>
                                <p>
                                    The normal waves have the property:
                                </p>
                                <pre>
Where:  U  is the frame being calculated.
        U1 is the previous frame.
        U2 is the frame before that.

And:    amplitude = U1
        momentum = U1 - U2
        acceleration = gaussian(U1) - U1

Then:   U = amplitude + momentum + acceleration
                                </pre>
                                <p>
                                    This describes how each point in the wave field evolves with
                                    no feedback.
                                </p>
                                <br>

                                <h3>4. ADDING FEEDBACK FROM WAVE MOTION:</h3>
                                <p>
                                    In the process of developing this, many attempts to add
                                    feedback and maintain the wave balance and integrity was
                                    tried.  Most did not work and resulted in invalid results.
                                </p>
                                <p>
                                    The process involved varying the array by shifting the
                                    values that are available up or down equally, but in
                                    different sub-ranges within the amplitude range.
                                </p>
                                <p>
                                    Several methods have been tried, one that was interesting is
                                    to clip the arrays at some level below the maximum.  This
                                    was discounted because it is believed it is not how
                                    natural waves work.  Although it may be relevant in places
                                    that have conditions that limit the freedom the waves can
                                    have.
                                </p>
                                <p>
                                    Which leaves spring like modifications and exponential
                                    shaping. And if these waves exist in free space, they will
                                    also respond to values associated with relativity.  Those
                                    are speed, and acceleration, and the total energy levels.
                                </p>
                                <p>
                                    With only the last few frames available, we have a
                                    relatively small set of values to draw from. So the method
                                    of used to derive the feedback expression start altering the
                                    values involved and observe what worked and what did not.
                                    Over the course of a year, the two lines below emerged as a
                                    solution that resulted in the most complex and varied
                                    behaviors with well behaved results.  It was found a bit
                                    later that using a Gaussian_filter instead of "Del"
                                    operator enabled scaling the QLets behaviors nicely. And
                                    then formula was improved in a number of steps.  But it's
                                    beautify results with the finite difference method suggests
                                    it is more than just a pretty picture. I believe this will
                                    connect to other fields.
                                </p>
                                <p>
                                    The feedback 'fb' includes acceleration and momentum with the
                                    amplitude.
                                </p>
                                <pre>
Where:     U  is the frame being calculated.
           U1 is the previous frame.
           U2 is the frame before that.

And:       U1                         ;Amplitude Of last frame.
           m = U1 - U2                ;Difference from previous frame.
           a = gaussian(U1) - U1      ;Gausian difference.

Next Wave: U = U1 + m + a             ;Without feedback.

Feedback:  r = 2.0 + (a + m)^2
           fb = (r + .5) / (r + (U1 + a - m/r)^2

New Wave:  U = U * fb                 ;With feedback.
                                </pre>
                                <br>

                                <h3>5. NOTES REGARDING THE FORMULA</h3>
                                <p>
                                    The first '2.0' value is a scaler where larger values
                                    reduce the effect of the other terms.  It can be increased
                                    to the point where the whole expression has little effect.
                                </p>
                                <p>
                                    The '0.5' value is a pivot for for the expression.  As the
                                    amplitude increases below or above it, the force to 
                                    return to center increases. So this acts like a membrane as
                                    often pictured in relativity.
                                </p>
                                <p>
                                    The term (a + m)^2 is the velocity of change of the amplitude.
                                    As this velocity increases,  it lessons the pull of the
                                    amplitude has back to center back to center. The effect is a
                                    wave takes longer to return to. So an increase in vertical wave
                                    speed result in a slowing of the horizontal speed. This is the
                                    cause of increased curl in the waves.
                                </p>
                                <p>
                                    The whole expression increases the force from that of the
                                    ideal perfect wave motion.  Because it varies from 1.0,
                                    proportional to the wave motion, it can simply be multiplied
                                    with the amplitude to get the total wave value for the next
                                    time step.
                                </p>
                                <p>
                                    You may notice time isn't represented in the equation, it's 
                                    value is always 1.0 in the stepwise direction, and so it
                                    either cancels out or is dropped.
                                </p>
                                <p>
                                    This sigma value used in the Gaussian filter determines the
                                    size of the convolution kernel. So larger sigma values increase
                                    the force the surrounding space has on each point.  But it
                                    also is normalized, so it decreases the force at the location
                                    it is calculated at.  So wider and lower.  This has the effect
                                    of scaling everything up or down.  A larger sigma value makes
                                    the waves lower and wider.  (also slower).  And smaller values
                                    result in small convolution kernels with steep sides, so
                                    everything gets smaller and faster.
                                </p>
                                <p>
                                    There are some practical limits. Sigma values below 0.5, don't
                                    have enough information to work correctly. A way around this is
                                    to increase the grid size and keep the sigma at levels where it
                                    is more accurate.  The down side to that is it takes longer to
                                    compute.
                                </p>
                                <p>
                                    No skipped computation steps.  The finite difference method has
                                    as nice property where at unit time steps, it results in
                                    perfect solutions. That statement should be taken to mean
                                    perfect in regards to the quality of the information used
                                </p>
                                <p>
                                    It is this property which gives results that seem to exceed the 
                                    resolution of the grid.  But it only works if every step
                                    is calculated without attempting to skip ahead. The speed of
                                    the program is controlled by increasing the number of steps
                                    between each displayed image.  Not by increasing a time factor
                                    between steps.
                                </p>
                                <p>
                                    Tests for neutral waves with no feedback results in perfect 
                                    solutions at each grid point. And works at extreme levels of
                                    amplitude.
                                </p>
                                <p>
                                    You can test this your self by setting the value of the
                                    first constant to one million which will effectively reduces
                                    the effect all other terms have.  The run it ahead about 10,000
                                    frames.  Then reverse it for another 10,000 frames.  It will
                                    recover the starting image nearly perfectly.  If the feedback
                                    is turned completely off, it recovers the image exactly.
                                </p>
                                <br>

                                <h3>5. PROGRAM NOTES:</h3>
                                <p>
                                    To analyze the results it was thought that particle like
                                    structures would have more extreme amplitude changes at the
                                    boundaries where they exist. Those characteristics can be
                                    easy visible if the waves are viewed with a gradient filter.
                                    This was confirmed to work very Well.
                                </p>
                                <p>
                                    The program is designed to allow changing the size of the
                                    arrays, the Sigma value used in the Gaussian filter, the two
                                    constants (2.0 and .5) and the two exponents. Many times it
                                    results in either an all white or black screen, and
                                    adjusting the amplitude color scale up or down will resolve
                                    that. Some results will just not work. But some are
                                    extremely stable and very beautiful.
                                </p>
                                <p>
                                    A note about update and video frequencies.  Modern video
                                    displays have limits.  And it's not needed to refresh the
                                    display as fast as possible.  So in between each video
                                    refresh, multiple array refreshes can take place.  This creates
                                    a timing light like relationship on the display, where you
                                    can sync the speed to the waves and they appear to  stop or
                                    reverse direction.  But they in fact are moving extremely
                                    fast. That effect has a nice benefit because it lets you see
                                    things happening that otherwise would not be visible.
                                </p>
                                <p>
                                    Also keep in mind this may run extremely slow on older
                                    computers and devices.  Keeping the Sigma values and array
                                    sizes small at first is a good idea.
                                </p>
                                <p>
                                    If you find bugs or know of a way to improve this, please
                                    contact me through the source you received it from.
                                </p>
                                <h4>
                                    Ron Adam  <a href = "mailto: ron3200@gmail.com">Send Email</a>
                                </h4>
                            </div>
                        </div>
                    </div>

                </div>
            </td>
        </tr>

<!-- Content ============================================================ -->

<tr>
    <td class="fit-width">
        
        <div class="card-rounded grad-grey small">
            <span class="tab14 green">Array Size:</span>
            <div class="tooltip">
                <input id="grid-size"
                       size="10"
                       value='256, 256'
                       onchange="set_grid_size(this.value)">
                <div class="tooltip-content">width, height</div>
            </div> 
            <br>
            <span class="tab14 green">Display Mode:</span>
            <div class="dropdown outline">
                <label id="Mode">Gradient</label>
                <div class="dropdown-content card-square">
                    <div class="dropdown-item" onMouseUp="set_display_mode(0)">Gradient</div>
                    <div class="dropdown-item" onMouseUp="set_display_mode(1)">Amplitude</div>
                    <div class="dropdown-item" onMouseUp="set_display_mode(2)">Momentum</div>
                    <div class="dropdown-item" onMouseUp="set_display_mode(3)">Acceleration</div>         
                </div>
            </div>
            <br>
            <span class="tab14 green">Edge Mode:</span>
            <div class="dropdown outline">
                <label id="Edge">Reflect</label>
                <div class="dropdown-content card-square">
                    <div class="dropdown-item" onMouseUp="set_edge_mode(0);">Reflect</div>
                    <div class="dropdown-item" onMouseUp="set_edge_mode(1);">Wrap</div>
                    <div class="dropdown-item" onMouseUp="set_edge_mode(2);">Rounded</div>
                </div>
            </div>
            <br>
            <span class="tab14 green">Image Seed:</span>
            <input id="Seed" type="text" size="10"
                   onchange="set_seed(parseInt(this.value))"><br>
            <div class="col space-left">
                <button onMouseUp="set_image()">Reset Image</button>          
                <button onMouseUp="random_image()">Random Image</button>
            </div>
        </div>
        
        <div class="card-rounded grad-grey small">
            <span class="green">Formula:</span>
            <br>
            <div style="padding-left: 2em; line-height: 2.0;">
                1.&nbsp;&nbsp;g = gaussian(u,
                <div class="tooltip">               
                    <input id="Sigma"
                           type="text" size="4"
                           onchange="set_value(this.id, parseFloat(this.value))"
                           name="Sigma">)
                    <div class="tooltip-content">Sigma</div>
                </div>
                <br>
                2.&nbsp;&nbsp;a = g - u
                <br>
                3.&nbsp;&nbsp;m = u - u1
                <br>
                4.&nbsp;&nbsp;w = u + a + m
                <br>
                5.&nbsp;&nbsp;r =
                <div class="tooltip">                
                    <input id="C1"
                           type="text" size="6"
                           onchange="set_value(this.id, parseFloat(this.value))"
                           name="C1"/>
                    <div class="tooltip-content">C1</div>
                </div>
                + |m + a|^
                <div class="tooltip">
                    <input id="E1"
                           type="text" size="3"
                           onchange="set_value(this.id, parseFloat(this.value))"
                           name="E1">
                    <div class="tooltip-content">E1</div>
                </div>
                <br>
                
                <div class="row middle">
                    <div class="col">
                        6.&nbsp;&nbsp;fb = &nbsp; &nbsp;
                    </div>
                    <div class="col fit-content">
                        <div class="row center">
                            (r + 
                            <div class="tooltip">
                                <input id="C2"
                                       type="text" size="4"
                                       onchange="set_value(this.id, parseFloat(this.value))"
                                       name="C2">
                                <div class="tooltip-content">C2</div>
                            </div>
                            )
                        </div>
                        <hr style="margin:0; padding:0;">                   
                        <div class="row">
                            (r + |u + a - m/r|^
                            <div class="tooltip">
                                <input id="E2"
                                       type="text" size="3"
                                       onchange="set_value(this.id, parseFloat(this.value))"
                                       name="E2">
                                <div class="tooltip-content">E2</div>
                            </div>
                            )
                        </div>
                    </div>
                </div>
                7. A = fb * w
                
                <div class="space-left">
                    <button onMouseUp="random_values()">Random Values</button>
                </div>
            </div>
        </div>
        
        <div class="card-rounded grad-grey small">
            <div class="row space-between">
                <div class="col">
                    <span class="green">Speed: </span>
                    <span class="tab10">
                        <input id="Speed" type="text" size="5" onchange="set_speed(parseFloat(this.value))">
                    </span>
                </div>
                <div class="col small">
                    <button id="Reverse" onMouseUp="reverse()"><b>&lt;&lt;</b></button>
                    <button id="Pause" onMouseUp="pause()"><b>&nbsp;#&nbsp;</b></button>
                    <button id="Forward" onMouseUp="forward()"><b>&gt;&gt;</b></button>
                </div>
            </div>
            <input  id="speed_slider" class="speed_slider" type="range" min="0" max="10000"
                    value="0" onMouseUp="set_speed_from_slider(this.value)">
            <script>
                var speed_slider = document.getElementById("speed_slider");
                speed_slider.oninput = function() {
                set_speed_from_slider(speed_slider.value)
                }
            </script>
        </div>

        <div class="card-rounded grad-grey small">
            <span class="green">Amplitude Scale:</span>
            <input id="Scale" type="text" size="5" onchange="set_scale(parseFloat(this.value))"><br>
            <input id="scale_slider"
                   class="speed_slider"
                   type="range" min="0" max="1000"
                   value="0"
                   onMouseUp="set_scale_from_slider(this.value)">
            <script>
                var scale_slider = document.getElementById("scale_slider");
                scale_slider.oninput = function() {
                set_scale_from_slider(scale_slider.value)
                }
            </script>
        </div>

    </td>  <!-- End column 1 -->

    
    <td class="fit-rest">
        <div style="margin:.5em;">
            <div id="canvas-area" class="canvas-area">
                <div id="coords" class="coords green">x, y</div>               
                <canvas id="canvas" class="canvas"
                        onmousemove="onMouseMove(event)"
                        onmouseleave="onMouseLeave()">
                </canvas>
                <script>
                    function onMouseLeave(){
                        document.getElementById('coords').style.display = 'none'
                        document.getElementById('canvas').style.cursor = 'default'                    
                    }
                    
                    function onMouseMove(e){
                        var coord_div = document.getElementById('coords')
                        var canvas = document.getElementById('canvas')
                        if (VALUES["Animating"]==0){
                            canvas.style.cursor = 'crosshair'
                            coord_div.style.display = 'block'
                            var rect = canvas.getBoundingClientRect()
                            var width = rect.right - rect.left
                            var height = rect.bottom - rect.top
                            var x = (e.x - rect.left)/width * VALUES['Width']
                            var y = (e.y - rect.top)/height * VALUES['Height']
                                                        
                            //coord_div.style.display = 'block'
                            if (e.x > rect.right - 80) {
                                coord_div.style.left = e.x - 75 + 'px' 
                            } else {
                                coord_div.style.left = e.x + 16 + 'px' 
                            }
                            if (e.y > rect.bottom - 35) {
                                coord_div.style.top = e.y - 32 +'px'
                            } else {
                                coord_div.style.top = e.y + 16 +'px' 
                            }
                            coord_div.innerHTML = x.toFixed(0)+", "+y.toFixed(0)                             
                        }else{
                            coord_div.style.display = 'none'
                            canvas.style.cursor = 'default'
                        }
                    }
                </script>                
            </div> 
        </div>
    </td>  <!-- End column 2 -->

</tr>  <!-- End main content row -->

<tr>
    <td colspan='2'>
        <div class="card-rounded grad-blue small space-between middle">
            <div>
                <span>Copyright all rights reserved 2021 by Ronald Adam</span>
                <span class="tab14">Version: 1.0A</span>
            </div>
            <div>
                <div class="tab16">Video FPS: <span id="video_frame_rate" style="color:#0000a0"> 0 </span></div>
                <div class="tab16">Sim. FPS: <span id="sim_frame_rate" style="color:#0000a0"> 0 </span></div> 
                <div class="tab16">Frame #: <span id="FrameCount" style="color:#0000a0"> 0 </span></div>
            </div>
            <div>
                <button onclick="copy_url()">Copy URL+Values</button>      
                <button onclick="copy_values()">Copy Values</button>
                <button onclick="document.getElementById('canvas').requestFullscreen()"> Full Screen </button>
            </div>
        </div>
    </td>
</tr>
    </table>
</body>
</html>
